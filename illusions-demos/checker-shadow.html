---
layout: null
permalink: /illusions/checker-shadow.html
---
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Adelson Checker–Shadow — interactive, mobile walkthrough</title>
<link rel="stylesheet" href="../assets/css/illusion-demo.css" />
<style>
  .demo-surface canvas { --demo-aspect: 1 / 1; }
  .control-note { font-size: 13px; color: #6b7280; margin: -6px 0 0; }
</style>
</head>
<body>
<main class="illusion-page">
  <section class="hero">
    <p class="kicker">Checker–shadow illusion</p>
    <h1>Slide the shadow strength to watch tiles A and B trade places</h1>
    <p class="lede">When a soft shadow sweeps across a checkerboard, identical tiles look wildly different. Start with the core control below, then scroll to unlock the full lab.</p>
    <div class="demo-frame">
      <p class="kicker">Live canvas</p>
      <div class="demo-surface">
        <canvas id="cv" aria-label="Adelson Checker–Shadow canvas"></canvas>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-shadow">
    <p class="kicker">Step 1 · Shadow strength</p>
    <h2>Turn the cast shadow up or down</h2>
    <p>With no shadow the checkerboard is boringly balanced. Strengthen it and the square inside the shade suddenly appears darker than its twin outside, even though the pixels remain identical.</p>
    <div class="controls">
      <div class="control-row">
        <label for="shadow">Shadow strength (multiplier)</label>
        <input id="shadow" type="range" min="20" max="95" value="50" />
        <span id="shadowVal" class="value">0.50×</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-angle">
    <p class="kicker">Step 2 · Light direction</p>
    <h2>Rotate the light source around the board</h2>
    <p>The perceptual trick depends on a convincing light direction. Adjust the angle or set it spinning to see how the apparent “lighter” tile swaps places.</p>
    <div class="controls">
      <div class="control-row">
        <label for="angle">Light angle (°)</label>
        <input id="angle" type="range" min="-180" max="180" value="30" />
        <span id="angleVal" class="value">30°</span>
      </div>
      <div class="button-row">
        <button id="animate" class="btn" type="button">Animate light</button>
        <button id="stopAnim" class="btn" type="button">Stop</button>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-softness">
    <p class="kicker">Step 3 · Shadow shape</p>
    <h2>Control width, length, softness, and the casting object</h2>
    <p>A long, soft-edged shadow makes the comparison more ambiguous. Reveal the cylinder to drag it and test different radii.</p>
    <div class="controls">
      <div class="control-row">
        <label for="shWidth">Shadow width (px)</label>
        <input id="shWidth" type="range" min="60" max="420" value="260" />
        <span id="shWidthVal" class="value">260</span>
      </div>
      <div class="control-row">
        <label for="shLength">Shadow length (px)</label>
        <input id="shLength" type="range" min="150" max="900" value="560" />
        <span id="shLengthVal" class="value">560</span>
      </div>
      <div class="control-row">
        <label for="soft">Shadow softness (px)</label>
        <input id="soft" type="range" min="5" max="120" value="60" />
        <span id="softVal" class="value">60</span>
      </div>
      <div class="control-check">
        <input id="showCyl" type="checkbox" checked />
        <label for="showCyl">Show cylinder (drag me)</label>
      </div>
      <div class="control-row">
        <label for="cylR">Cylinder radius (px)</label>
        <input id="cylR" type="range" min="30" max="140" value="80" />
        <span id="cylRVal" class="value">80</span>
      </div>
      <p class="control-note">Tip: drag the cylinder directly on the canvas; the shadow updates instantly.</p>
    </div>
  </section>

  <section class="stage" id="stage-board">
    <p class="kicker">Step 4 · Board and palette</p>
    <h2>Adjust the checkerboard itself</h2>
    <p>Once you believe the illusion, explore how board size and tile contrast change its potency. Strong contrast and a generous margin keep the comparison readable.</p>
    <div class="controls">
      <div class="control-row">
        <label for="n">Squares per side</label>
        <input id="n" type="range" min="6" max="16" value="8" />
        <span id="nVal" class="value">8</span>
      </div>
      <div class="control-row">
        <label for="size">Square size (px)</label>
        <input id="size" type="range" min="30" max="120" value="70" />
        <span id="sizeVal" class="value">70</span>
      </div>
      <div class="control-row">
        <label for="margin">Board margin (px)</label>
        <input id="margin" type="range" min="20" max="120" value="60" />
        <span id="marginVal" class="value">60</span>
      </div>
      <div class="control-row">
        <label for="Ldark">Dark square lightness</label>
        <input id="Ldark" type="range" min="5" max="60" value="35" />
        <span id="LdarkVal" class="value">35%</span>
      </div>
      <div class="control-row">
        <label for="Llight">Light square lightness</label>
        <input id="Llight" type="range" min="40" max="95" value="70" />
        <span id="LlightVal" class="value">70%</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-reveal">
    <p class="kicker">Step 5 · Proof tools</p>
    <h2>Fade the context and bridge the twins</h2>
    <p>Labels and reveals help you convince sceptical audiences. Fade the surroundings, lock the luminance equality, or draw a connecting strip to show the tiles really match.</p>
    <div class="controls">
      <div class="control-check">
        <input id="showLabels" type="checkbox" checked />
        <label for="showLabels">Show labels A &amp; B</label>
      </div>
      <div class="control-check">
        <input id="lockEq" type="checkbox" checked />
        <label for="lockEq">Lock equality (A shade = B shade)</label>
      </div>
      <div class="control-row">
        <label for="fade">Context fade (reveal)</label>
        <input id="fade" type="range" min="0" max="100" value="0" />
        <span id="fadeVal" class="value">0%</span>
      </div>
      <div class="button-row">
        <button id="bridge" class="btn" type="button">Draw bridging strip</button>
        <button id="clearBridge" class="btn" type="button">Clear strip</button>
        <span class="badge">Prove they’re identical</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-presets">
    <p class="kicker">Step 6 · Presets & export</p>
    <h2>Jump to favourite setups or save the canvas</h2>
    <p>Use curated presets for classroom demos, or export a PNG/SVG snapshot when you find a configuration that astonishes people.</p>
    <div class="controls">
      <div class="button-row">
        <button class="btn" id="presetClassic" type="button">Classic setup</button>
        <button class="btn" id="presetWide" type="button">Wide soft shadow</button>
        <button class="btn" id="presetDramatic" type="button">Dramatic contrast</button>
      </div>
      <div class="button-row">
        <button id="exportPng" class="btn" type="button">Export PNG</button>
        <button id="exportSvg" class="btn" type="button">Export SVG</button>
        <button id="reset" class="btn" type="button">Reset</button>
      </div>
    </div>
  </section>
</main>
<script>
(() => {
  const $ = id => document.getElementById(id);
  const cv = $('cv');
  const ctx = cv.getContext('2d');

  // Controls
  const ctl = {
    n: $('n'), size:$('size'), margin:$('margin'),
    Ldark:$('Ldark'), Llight:$('Llight'),
    shadow:$('shadow'), soft:$('soft'), shWidth:$('shWidth'), shLength:$('shLength'),
    angle:$('angle'), showCyl:$('showCyl'), cylR:$('cylR'),
    showLabels:$('showLabels'), lockEq:$('lockEq'), fade:$('fade')
  };
  const lab = {
    n:$('nVal'), size:$('sizeVal'), margin:$('marginVal'),
    Ldark:$('LdarkVal'), Llight:$('LlightVal'),
    shadow:$('shadowVal'), soft:$('softVal'), shWidth:$('shWidthVal'), shLength:$('shLengthVal'),
    angle:$('angleVal'), cylR:$('cylRVal'), fade:$('fadeVal')
  };

  // State
  const state = {
    // Canvas
    dpr: 1,
    // Cylinder & shadow
    cylX: 0, cylY: 0,
    anim: null,
    // A/B labels on alternating tiles
  A: { r: 1, c: 1 }, // DARK tile (even sum) in light
  B: { r: 2, c: 3 }, // LIGHT tile (odd sum) under shadow
    bridgeOn: false
  };

  /* ----------------- utilities ----------------- */
  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    state.dpr = dpr;
    const rect = cv.getBoundingClientRect();
    cv.width = Math.round(rect.width * dpr);
    cv.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function L_to_rgb(L){ // greyscale from 0..100% (sRGB approx)
    const v = Math.round(255 * (L/100));
    const h = v.toString(16).padStart(2,'0');
    return `#${h}${h}${h}`;
  }

  function lerp(a,b,t){ return a + (b-a)*t; }
  function clamp(v,a,b){ return Math.min(b, Math.max(a, v)); }

  // Signed distance to a capsule (rounded rectangle) centred at (0,0), along +x of length L and radius R
  function sdCapsuleLocal(x,y,L,R){
    // Map to central rectangle of half-length h = L/2
    const h = L/2;
    const qx = Math.abs(x) - h;
    const qy = y;
    const ax = Math.max(qx, 0);
    const ay = Math.max(Math.abs(qy) - R, 0);
    const outside = Math.hypot(ax, ay);
    const inside = Math.min(Math.max(qx, Math.abs(qy) - R), 0);
    return outside + inside; // negative inside
  }

  // Shadow factor at world coords (x,y)
  // 'angleRad' here is the SHADOW direction (i.e., opposite of light direction)
  // Cast shadow is a one-sided capsule that starts at the back rim of the cylinder (anchored to radius)
  function shadowAt(x,y, cx,cy, angleRad, width, length, softPx, strength, cylR=0){
    // Transform to shadow-local coords (x along shadow direction)
    const cos = Math.cos(angleRad), sin = Math.sin(angleRad);
    const lx =  (x - cx) * cos + (y - cy) * sin;
    const ly = -(x - cx) * sin + (y - cy) * cos;
    // Build a capsule whose extent is [cylR, cylR+length] along +x, width as provided
    const L = Math.max(1, length);
    const W = Math.max(1, width);
    const centerX = cylR + L/2; // center so that near edge sits at x = cylR
    const d = sdCapsuleLocal(lx - centerX, ly, L, W/2);
    // Points in front of the cylinder (lx < cylR) are not in shadow; push distance positive
    const dClipped = (lx < cylR) ? Math.abs(cylR - lx) + Math.max(0, Math.abs(ly) - W/2) : d;
    // Edge softness
    const tEdge = clamp(0.5 - dClipped / Math.max(1, softPx), 0, 1);
    // Distance falloff (farther from cylinder → lighter)
    const dist01 = clamp((lx - cylR) / L, 0, 1);
    const strengthFar = 0.82; // slightly lighter far away for realism
    const localStrength = lerp(strength, strengthFar, dist01);
    return lerp(1.0, localStrength, tEdge);
  }

  // Convert tile (r,c) to centre world coords
  function tileCentre(r, c, board){
    const x = board.x0 + c * (board.size) + board.size/2;
    const y = board.y0 + r * (board.size) + board.size/2;
    return {x,y};
  }

  // Determine if a tile is "light" or "dark" by parity
  function isLight(r,c){ return ((r + c) % 2) === 1; }

  /* ----------------- drawing ----------------- */
  function draw(){
    const W = cv.width / state.dpr, H = cv.height / state.dpr;
    ctx.clearRect(0,0,W,H);

    // Labels
    lab.n.textContent = ctl.n.value;
    lab.size.textContent = ctl.size.value;
    lab.margin.textContent = ctl.margin.value;
    lab.Ldark.textContent = ctl.Ldark.value + '%';
    lab.Llight.textContent = ctl.Llight.value + '%';
    lab.shadow.textContent = (ctl.shadow.value/100).toFixed(2) + '×';
    lab.soft.textContent = ctl.soft.value;
    lab.shWidth.textContent = ctl.shWidth.value;
    lab.shLength.textContent = ctl.shLength.value;
    lab.angle.textContent = ctl.angle.value + '°';
    lab.cylR.textContent = ctl.cylR.value;
    lab.fade.textContent = ctl.fade.value + '%';

    // Board geometry
    const n = +ctl.n.value;
    const size = +ctl.size.value;
    const margin = +ctl.margin.value;
    const boardW = n * size;
    const boardH = boardW;
    const cxBoard = W/2, cyBoard = H/2;
    const x0 = cxBoard - boardW/2;
    const y0 = cyBoard - boardH/2;
    const board = { x0, y0, size, n };

    // Place cylinder default if first draw
    if (state.cylX === 0 && state.cylY === 0){
      state.cylX = x0 + size*1.2;
      state.cylY = y0 + size*1.6;
    }

    // Shadow parameters
  // Light vs shadow: UI controls the LIGHT angle; the SHADOW points opposite
  const lightAngle = (+ctl.angle.value) * Math.PI/180;
  const shadowAngle = lightAngle + Math.PI; // cast direction
    const shWidth = +ctl.shWidth.value;
    const shLength = +ctl.shLength.value;
    const softPx = +ctl.soft.value;
    const strength = (+ctl.shadow.value)/100;
    const cylR = +ctl.cylR.value;

    // Fade (context reveal)
    const fadeK = (+ctl.fade.value)/100; // 0..1

    // Draw background (context)
    ctx.save();
    ctx.globalAlpha = 1 - fadeK;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,W,H);

  // (moved) contact shadow ring is drawn after the board so it’s visible

    // Draw checkerboard with multiplicative shadow applied per tile
    const Ld = +ctl.Ldark.value;
    let Ll = +ctl.Llight.value;

    // If lock equality: set dark so that A(dark with sA) == B(light with sB) in physical luminance
    if (ctl.lockEq.checked){
      const AC = tileCentre(state.A.r, state.A.c, board);
      const BC = tileCentre(state.B.r, state.B.c, board);
      const sA = shadowAt(AC.x, AC.y, state.cylX, state.cylY, shadowAngle, shWidth, shLength, softPx, strength, cylR);
      const sB = shadowAt(BC.x, BC.y, state.cylX, state.cylY, shadowAngle, shWidth, shLength, softPx, strength, cylR);
      // Choose Ldark such that Ll*sB == Ldark*sA, guarding against tiny sA values
      const eps = 1e-6;
      const newLd = (Ll * sB) / Math.max(eps, sA);
      lab.Ldark.textContent = newLd.toFixed(1) + '%';
      drawCheckerboard(board, Ll, newLd, {angleRad: shadowAngle, shWidth, shLength, softPx, strength});
    } else {
  drawCheckerboard(board, Ll, Ld, {angleRad: shadowAngle, shWidth, shLength, softPx, strength});
    }

    // Cylinder base contact shadow on the board (multiply)
    if (ctl.showCyl.checked){
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 0.28 * (1 - fadeK);
      ctx.translate(state.cylX, state.cylY);
      const ringR = cylR * 0.9;
      const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, ringR);
      grd.addColorStop(0, 'rgba(0,0,0,0.4)');
      grd.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.ellipse(0, 0, ringR * 1.5, ringR * 0.7, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Cylinder (on top of board and contact shadow)
    if (ctl.showCyl.checked){
      drawCylinder(state.cylX, state.cylY, cylR, lightAngle);
    }

    // Shadow capsule (for fun, faint overlay of the umbra)
  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  ctx.globalAlpha = 0.08 * (1 - fadeK);
  ctx.translate(state.cylX, state.cylY);
  ctx.rotate(shadowAngle);
  ctx.fillStyle = '#000';
  roundedHalfCapsule(ctx, cylR, 0, shLength, shWidth, shWidth/2);
  ctx.fill();
  ctx.restore();

    // Labels & bridge
    if (ctl.showLabels.checked){
      drawLabels(board, fadeK);
    }
    if (state.bridgeOn){
      drawBridge(board, fadeK);
    }

    ctx.restore(); // end of context fade

    // Foreground white overlay to implement fade (“reveal”)
    if (fadeK > 0){
      ctx.save();
      ctx.globalAlpha = fadeK;
      // Paint only board area with flat mid-grey that matches both A & B
      const AC = tileCentre(state.A.r, state.A.c, board);
      const BC = tileCentre(state.B.r, state.B.c, board);
  const params = {angleRad: shadowAngle, shWidth, shLength, softPx, strength};
      const LA = physicalLuminanceAt(state.A.r, state.A.c, board, params);
      const LB = physicalLuminanceAt(state.B.r, state.B.c, board, params);
      const mid = (LA + LB)/2;
      ctx.fillStyle = L_to_rgb(mid);
      ctx.fillRect(x0 - margin, y0 - margin, boardW + 2*margin, boardH + 2*margin);
      ctx.restore();
      // Redraw A/B labels on top
      if (ctl.showLabels.checked){
        drawLabels(board, 0);
        if (state.bridgeOn) drawBridge(board, 0);
      }
    }
  }

  function drawCheckerboard(board, Ll, Ld, sh){
    const { x0, y0, size, n } = board;
    for (let r=0; r<n; r++){
      for (let c=0; c<n; c++){
        const light = isLight(r,c);
        // base lightness
        let L = light ? Ll : Ld;
        const centre = tileCentre(r,c, board);
  const s = shadowAt(centre.x, centre.y, state.cylX, state.cylY, sh.angleRad, sh.shWidth, sh.shLength, sh.softPx, sh.strength, +ctl.cylR.value);
        L = clamp(L * s, 0, 100);
        ctx.fillStyle = L_to_rgb(L);
        ctx.fillRect(x0 + c*size, y0 + r*size, size, size);
      }
    }
    // board border
    ctx.save();
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.strokeRect(x0, y0, n*size, n*size);
    ctx.restore();
  }

  function drawCylinder(x,y, R, lightAngle){
    // Draw a shaded cylinder with lighting aligned to lightAngle.
    // y is the base; the top sits at y - H.
    const H = Math.max(48, R * 1.6);
    ctx.save();
    ctx.translate(x, y);

    // ---- Body gradient: create in a rotated frame so it truly faces the light.
    ctx.save();
    ctx.rotate(lightAngle); // rotate only for gradient creation
    const bodyGrad = ctx.createLinearGradient(-R, 0, R, 0);
    bodyGrad.addColorStop(0.00, '#0c4d1f');
    bodyGrad.addColorStop(0.25, '#1f7f3d');
    bodyGrad.addColorStop(0.50, '#2ea44f');
    bodyGrad.addColorStop(0.75, '#1f7f3d');
    bodyGrad.addColorStop(1.00, '#0b4120');
    ctx.restore();

    // Body
    ctx.fillStyle = bodyGrad;
    ctx.strokeStyle = '#0b4a22';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.rect(-R, -H, 2*R, H);
    ctx.fill();
    ctx.stroke();

    // ---- Top ellipse with radial shading towards the light
    const lx = Math.cos(lightAngle), ly = Math.sin(lightAngle);
    const topGrad = ctx.createRadialGradient(lx*R*0.25, -H + ly*R*0.10, R*0.18, 0, -H, R*1.05);
    topGrad.addColorStop(0, '#6bda90');
    topGrad.addColorStop(1, '#1b6734');
    ctx.fillStyle = topGrad;
    ctx.beginPath();
    ctx.ellipse(0, -H, R, R*0.35, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // ---- Soft contact rim at the base (very subtle)
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.beginPath();
    ctx.ellipse(0, 0, R*1.04, R*0.36, 0, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.stroke();
    ctx.restore();

    // ---- Specular streak on the body, aligned to light
    ctx.save();
    ctx.rotate(lightAngle);
    ctx.translate(-R*0.55, -H*0.55);
    ctx.beginPath();
    ctx.ellipse(0, 0, R*0.18, R*0.08, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fill();
    ctx.restore();

    ctx.restore();
  }

  function roundedCapsule(ctx, x, y, length, width, r){
    ctx.beginPath();
    const L = length, W = width, R = r;
    ctx.moveTo(x - L/2, y - W/2 + R);
    ctx.arcTo(x - L/2, y - W/2, x - L/2 + R, y - W/2, R);
    ctx.lineTo(x + L/2 - R, y - W/2);
    ctx.arcTo(x + L/2, y - W/2, x + L/2, y - W/2 + R, R);
    ctx.lineTo(x + L/2, y + W/2 - R);
    ctx.arcTo(x + L/2, y + W/2, x + L/2 - R, y + W/2, R);
    ctx.lineTo(x - L/2 + R, y + W/2);
    ctx.arcTo(x - L/2, y + W/2, x - L/2, y + W/2 - R, R);
    ctx.closePath();
  }

  function roundedHalfCapsule(ctx, startX, y, length, width, r){
    // Capsule that starts at startX and extends to startX + length along +x
    const L = length, W = width, R = r;
    const x0 = startX, x1 = startX + L;
    ctx.beginPath();
    // Near semicircle at x0
    ctx.moveTo(x0, y - W/2 + R);
    ctx.arcTo(x0, y - W/2, x0 + R, y - W/2, R);
    ctx.lineTo(x1 - R, y - W/2);
    ctx.arcTo(x1, y - W/2, x1, y - W/2 + R, R);
    ctx.lineTo(x1, y + W/2 - R);
    ctx.arcTo(x1, y + W/2, x1 - R, y + W/2, R);
    ctx.lineTo(x0 + R, y + W/2);
    ctx.arcTo(x0, y + W/2, x0, y + W/2 - R, R);
    ctx.closePath();
  }

  function drawLabels(board, fadeK){
    const {size} = board;
    const AC = tileCentre(state.A.r, state.A.c, board);
    const BC = tileCentre(state.B.r, state.B.c, board);
    labelAt('A', AC.x, AC.y, size, fadeK);
    labelAt('B', BC.x, BC.y, size, fadeK);
  }

  function labelAt(text, x, y, size, fadeK){
    ctx.save();
    ctx.font = `bold ${Math.round(size*0.5)}px ui-sans-serif, system-ui, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'rgba(0,0,0,'+(0.85*(1-fadeK))+')';
    ctx.strokeStyle = 'rgba(255,255,255,'+(0.9*(1-fadeK))+')';
    ctx.lineWidth = Math.max(1, size*0.08);
    ctx.strokeText(text, x, y);
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  function drawBridge(board, fadeK){
    const AC = tileCentre(state.A.r, state.A.c, board);
    const BC = tileCentre(state.B.r, state.B.c, board);
    // Take physical luminance at A (same as B when equality is locked) and paint a strip between
    const params = {
  angleRad:(+ctl.angle.value)*Math.PI/180 + Math.PI,
      shWidth:+ctl.shWidth.value, shLength:+ctl.shLength.value,
      softPx:+ctl.soft.value, strength:(+ctl.shadow.value)/100
    };
    const LA = physicalLuminanceAt(state.A.r, state.A.c, board, params);
    ctx.save();
    ctx.globalAlpha = 0.95*(1-fadeK);
    ctx.strokeStyle = L_to_rgb(LA);
    ctx.lineWidth = Math.max(10, board.size*0.2);
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(AC.x, AC.y);
    ctx.lineTo(BC.x, BC.y);
    ctx.stroke();
    ctx.restore();
  }

  function physicalLuminanceAt(r,c, board, sh){
    // Return the greyscale lightness (0..100) actually drawn at that tile
    const Ld = +ctl.Ldark.value;
    const Ll = +ctl.Llight.value;
    let base = isLight(r,c) ? Ll : Ld;
    const centre = tileCentre(r,c, board);
  const s = shadowAt(centre.x, centre.y, state.cylX, state.cylY, sh.angleRad, sh.shWidth, sh.shLength, sh.softPx, sh.strength, +ctl.cylR.value);
    if (ctl.lockEq.checked){
      // Under lock, set dark so that A(dark with sA) matches B(light with sB)
      const AC = tileCentre(state.A.r, state.A.c, board);
      const BC = tileCentre(state.B.r, state.B.c, board);
      const sA = shadowAt(AC.x, AC.y, state.cylX, state.cylY, sh.angleRad, sh.shWidth, sh.shLength, sh.softPx, sh.strength, +ctl.cylR.value);
      const sB = shadowAt(BC.x, BC.y, state.cylX, state.cylY, sh.angleRad, sh.shWidth, sh.shLength, sh.softPx, sh.strength, +ctl.cylR.value);
      const eps = 1e-6;
      const newLd = (Ll * sB) / Math.max(eps, sA);
      base = isLight(r,c) ? Ll : newLd;
    }
    return clamp(base * s, 0, 100);
  }

  /* ----------------- interaction ----------------- */
  function bindInputs(){
    // Sliders/checkboxes trigger redraw
    Object.values(ctl).forEach(input=>{
      const ev = (input.type==='checkbox')?'change':'input';
      input.addEventListener(ev, ()=>{ draw(); }, {passive:true});
    });

    // Presets
  function pickABForClassicLocal(board, angleRadShadow, shWidth, shLength, softPx, strength, cylR){
      const {x0,y0,size,n} = board; const W = cv.width/state.dpr, H = cv.height/state.dpr;
      const cx=W/2, cy=H/2; const d2=(r,c)=>{ const x=x0+c*size+size/2, y=y0+r*size+size/2; const dx=x-cx, dy=y-cy; return dx*dx+dy*dy; };
      const sAt=(r,c)=>{ const x=x0+c*size+size/2, y=y0+r*size+size/2; return shadowAt(x,y, state.cylX, state.cylY, angleRadShadow, shWidth, shLength, softPx, strength, cylR); };
      const isLight=(r,c)=>((r+c)%2)===1;
      let bestB=null, bestBd=1e15; // light in shadow
      for(let r=0;r<n;r++) for(let c=0;c<n;c++) if(isLight(r,c)){
        const s=sAt(r,c); if(s>0.8) continue; // require decent shadow
        const dist=d2(r,c); if(dist<bestBd){ bestBd=dist; bestB={r,c}; }
      }
      let bestA=null, bestAd=1e15; // dark outside (fully out of shadow)
      for(let r=0;r<n;r++) for(let c=0;c<n;c++) if(!isLight(r,c)){
        const s=sAt(r,c); if(s<0.999) continue; // pick only tiles with no shadow influence
        const dist=d2(r,c); if(dist<bestAd){ bestAd=dist; bestA={r,c}; }
      }
      state.A = bestA || {r:1,c:1};
      state.B = bestB || {r:2,c:3};
    }

    $('presetClassic').addEventListener('click', ()=>{
      ctl.n.value=8; ctl.size.value=70; ctl.margin.value=60;
      ctl.Ldark.value=35; ctl.Llight.value=70;
      ctl.shadow.value=50; ctl.soft.value=60; ctl.shWidth.value=Math.round(+ctl.cylR.value*2.0); ctl.shLength.value=560;
      ctl.angle.value=30; ctl.cylR.value=80; ctl.showCyl.checked=true;
      state.cylX = (cv.width/state.dpr)/2 - 120; state.cylY = (cv.height/state.dpr)/2 + 20;
      ctl.showLabels.checked=true; ctl.lockEq.checked=true; ctl.fade.value=0;
      // Choose A/B to match classic Adelson using current board geometry
      const n = +ctl.n.value, size=+ctl.size.value, margin=+ctl.margin.value;
      const boardW=n*size; const boardH=boardW; const W=cv.width/state.dpr, H=cv.height/state.dpr;
      const x0=W/2 - boardW/2, y0=H/2 - boardH/2; const board={x0,y0,size,n};
      const lightAngle=(+ctl.angle.value)*Math.PI/180; const shadowAngle=lightAngle+Math.PI;
      pickABForClassicLocal(board, shadowAngle, +ctl.shWidth.value, +ctl.shLength.value, +ctl.soft.value, (+ctl.shadow.value)/100, +ctl.cylR.value);
      state.bridgeOn=false;
      draw();
    });
    $('presetWide').addEventListener('click', ()=>{
      ctl.shadow.value=60; ctl.soft.value=100; ctl.shWidth.value=360; ctl.shLength.value=760; ctl.angle.value=20; draw();
    });
    $('presetDramatic').addEventListener('click', ()=>{
      ctl.Ldark.value=30; ctl.Llight.value=80; ctl.shadow.value=45; ctl.soft.value=40; ctl.shWidth.value=220; ctl.shLength.value=620; ctl.angle.value=45; draw();
    });

    // Bridge toggle
    $('bridge').addEventListener('click', ()=>{ state.bridgeOn = true; draw(); });
    $('clearBridge').addEventListener('click', ()=>{ state.bridgeOn = false; draw(); });

    // Animate light
    $('animate').addEventListener('click', ()=>{
      if (state.anim) return;
      let t= (+ctl.angle.value) * Math.PI/180;
      const step = ()=>{
        if (!state.anim) return;
        t += 0.01;
        ctl.angle.value = Math.round((t*180/Math.PI + 180)%360 - 180);
        draw();
        state.anim = requestAnimationFrame(step);
      };
      state.anim = requestAnimationFrame(step);
    });
    $('stopAnim').addEventListener('click', ()=>{
      if (state.anim){ cancelAnimationFrame(state.anim); state.anim=null; }
    });

    // Reset
    $('reset').addEventListener('click', ()=>{
      Object.assign(ctl, ctl); // no-op, just clarity
      $('presetClassic').click();
    });

    // Export PNG
    $('exportPng').addEventListener('click', ()=>{
      const a=document.createElement('a');
      a.download='checker-shadow.png';
      a.href=cv.toDataURL('image/png');
      a.click();
    });

    // Export SVG (vector board + labels + cylinder + shadow outline + bridge; shadow soft edges not exported)
    $('exportSvg').addEventListener('click', ()=>{
      const rect = cv.getBoundingClientRect();
      const W = Math.round(rect.width), H = Math.round(rect.height);
      const n = +ctl.n.value, size=+ctl.size.value, margin=+ctl.margin.value;
      const boardW = n*size, boardH = boardW;
      const x0 = W/2 - boardW/2, y0 = H/2 - boardH/2;
      const Ld = +ctl.Ldark.value, Ll = +ctl.Llight.value;
  const angleRadLight = (+ctl.angle.value)*Math.PI/180;
  const angleRadShadow = angleRadLight + Math.PI;
  const shWidth=+ctl.shWidth.value, shLength=+ctl.shLength.value;
  const cylR=+ctl.cylR.value;

      const parts = [];
      parts.push(`<rect x="0" y="0" width="${W}" height="${H}" fill="#ffffff"/>`);
      // Checkerboard (no soft shadow in SVG export; this is a “flat reveal” for publication)
      for(let r=0;r<n;r++){
        for(let c=0;c<n;c++){
          const L = isLight(r,c) ? Ll : Ld;
          const col = L_to_rgb(L);
          parts.push(`<rect x="${x0 + c*size}" y="${y0 + r*size}" width="${size}" height="${size}" fill="${col}" />`);
        }
      }
      // Cylinder (SVG approximation: body rectangle with top ellipse)
      if (ctl.showCyl.checked){
        const H = (cylR * 1.6).toFixed(2);
        parts.push(`<rect x="${(state.cylX - cylR).toFixed(2)}" y="${(state.cylY - H).toFixed(2)}" width="${(cylR*2).toFixed(2)}" height="${H}" fill="#2ea44f" stroke="#0b4a22"/>`);
        parts.push(`<ellipse cx="${state.cylX.toFixed(2)}" cy="${(state.cylY - H).toFixed(2)}" rx="${cylR.toFixed(2)}" ry="${(cylR*0.35).toFixed(2)}" fill="#2ea44f" stroke="#0b4a22"/>`);
      }
      // Shadow outline half-capsule anchored to cylinder back rim
      const cx = state.cylX, cy = state.cylY;
      const path = halfCapsulePathSvg(cx, cy, cylR, shLength, shWidth, angleRadShadow);
      parts.push(`<path d="${path}" fill="none" stroke="rgba(0,0,0,0.12)" />`);

      // Labels
      if (ctl.showLabels.checked){
        const AC = tileCentre(state.A.r, state.A.c, {x0,y0,size,n});
        const BC = tileCentre(state.B.r, state.B.c, {x0,y0,size,n});
        parts.push(`<text x="${AC.x}" y="${AC.y}" font-family="Arial,Segoe UI,system-ui" font-size="${Math.round(size*0.5)}" text-anchor="middle" dominant-baseline="middle" fill="#000">A</text>`);
        parts.push(`<text x="${BC.x}" y="${BC.y}" font-family="Arial,Segoe UI,system-ui" font-size="${Math.round(size*0.5)}" text-anchor="middle" dominant-baseline="middle" fill="#000">B</text>`);
        if (state.bridgeOn){
          parts.push(`<line x1="${AC.x}" y1="${AC.y}" x2="${BC.x}" y2="${BC.y}" stroke="${L_to_rgb(Ll)}" stroke-width="${Math.max(10, size*0.2)}" stroke-linecap="round" />`);
        }
      }

      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">${parts.join('\n')}</svg>`;
      const blob=new Blob([svg], {type:'image/svg+xml'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download='checker-shadow.svg'; a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 2000);
    });

    function halfCapsulePathSvg(cx, cy, R, L, W, ang){
      // Half-capsule from x=R to x=R+L rotated by ang
      const r = W/2;
      const p = [
        [R, -W/2 + r], [R, -W/2], [R + r, -W/2],
        [R + L - r, -W/2], [R + L, -W/2], [R + L, -W/2 + r],
        [R + L,  W/2 - r], [R + L,  W/2], [R + L - r,  W/2],
        [R + r,  W/2], [R,  W/2], [R,  W/2 - r]
      ];
      const cos = Math.cos(ang), sin = Math.sin(ang);
      const rot = (px,py)=>[ cx + px*cos - py*sin, cy + px*sin + py*cos ];
      const A = p.map(([px,py])=>rot(px,py));
      return `M ${A[0][0]} ${A[0][1]} L ${A[2][0]} ${A[2][1]} L ${A[3][0]} ${A[3][1]} L ${A[5][0]} ${A[5][1]} L ${A[6][0]} ${A[6][1]} L ${A[8][0]} ${A[8][1]} L ${A[9][0]} ${A[9][1]} L ${A[11][0]} ${A[11][1]} Z`;
    }

    // Drag cylinder
    let dragging = false;
    cv.addEventListener('mousedown', (e)=>{
      const pt = clientToCanvas(e);
      if (hitCylinder(pt.x, pt.y)){
        dragging = true;
      }
    });
    cv.addEventListener('mousemove', (e)=>{
      if (!dragging) return;
      const pt = clientToCanvas(e);
      state.cylX = pt.x; state.cylY = pt.y;
      draw();
    });
    window.addEventListener('mouseup', ()=> dragging=false);
    cv.addEventListener('touchstart', (e)=>{
      const t = e.touches[0]; const pt = clientToCanvas(t);
      if (hitCylinder(pt.x, pt.y)) dragging=true;
    }, {passive:true});
    cv.addEventListener('touchmove', (e)=>{
      if (!dragging) return;
      const t = e.touches[0]; const pt = clientToCanvas(t);
      state.cylX = pt.x; state.cylY = pt.y; draw();
    }, {passive:true});
    window.addEventListener('touchend', ()=> dragging=false, {passive:true});

    function clientToCanvas(e){
      const rect = cv.getBoundingClientRect();
      return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
    }
    function hitCylinder(x,y){
      const dx = x - state.cylX, dy = y - state.cylY;
      return Math.hypot(dx,dy) <= (+ctl.cylR.value) * 1.1;
    }
  }

  /* ----------------- boot ----------------- */
  function init(){
    fitCanvas();
    window.addEventListener('resize', ()=>{ fitCanvas(); draw(); }, {passive:true});
    bindInputs();
    // Default to classic preset
    $('presetClassic').click();
  }
  init();
})();
</script>
</body>
</html>