<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Müller–Lyer Illusion — step-by-step interactive</title>
<link rel="stylesheet" href="../assets/css/illusion-demo.css" />
<style>
  .demo-surface canvas { --demo-aspect: 3 / 2; }
</style>
</head>
<body>
<main class="illusion-page">
  <section class="hero">
    <p class="kicker">Müller–Lyer illusion</p>
    <h1>Use the length slider to chase the point of subjective equality</h1>
    <p class="lede">Arrowheads and arrowtails push the endpoints of a line inward or outward. Slide the length offset until both shafts look equal, then scroll to reveal how each component modulates the illusion.</p>
    <div class="demo-frame">
      <p class="kicker">Live canvas</p>
      <div class="demo-surface">
        <canvas id="cv" aria-label="Müller–Lyer illusion canvas"></canvas>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-psychophysics">
    <p class="kicker">Step 1 · Length offset</p>
    <h2>Match the shafts by eye</h2>
    <p>Keep the lengths locked and adjust the offset until the two shafts appear identical. The required offset is your personal point of subjective equality (PSE).</p>
    <div class="controls">
      <div class="control-row">
        <label for="delta">Length offset (top − bottom, px)</label>
        <input id="delta" type="range" min="-200" max="200" value="0" />
        <span id="deltaVal" class="value">0</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-presets">
    <p class="kicker">Step 2 · Classic pairs</p>
    <h2>Switch between canonical Müller–Lyer configurations</h2>
    <p>Each preset sets both the top and bottom figures. Jump between arrowheads, arrowtails, t-caps, and other combinations to see how the illusion changes, then choose whether the shafts stay physically equal.</p>
    <div class="controls">
      <div class="control-check">
        <input id="lockEq" type="checkbox" checked />
        <label for="lockEq">Lock lengths equal</label>
      </div>
      <div id="pairPresets" class="button-row presets"></div>
    </div>
  </section>

  <section class="stage" id="stage-global">
    <p class="kicker">Step 3 · Global framing</p>
    <h2>Adjust the canvas margin, colours, and striped backgrounds</h2>
    <p>Framing and context alter how strong the illusion feels. Striped backgrounds can add assimilation cues that bias your judgement.</p>
    <div class="controls">
      <div class="control-row">
        <label for="margin">Canvas margin (px)</label>
        <input id="margin" type="range" min="10" max="160" value="80" />
        <span id="marginVal" class="value">80</span>
      </div>
      <div class="control-row">
        <label for="colour">Line colour</label>
        <select id="colour">
          <option value="#111111" selected>Black</option>
          <option value="#0057ff">Blue</option>
          <option value="#ff0055">Magenta</option>
          <option value="#00a56a">Teal</option>
        </select>
        <span class="value" aria-hidden="true"></span>
      </div>
      <div class="control-row">
        <label for="bgStripes">Background stripes (assimilation)</label>
        <select id="bgStripes">
          <option value="none" selected>None</option>
          <option value="parallel">Parallel to shafts</option>
          <option value="orthogonal">Orthogonal to shafts</option>
        </select>
        <span class="value" aria-hidden="true"></span>
      </div>
      <div class="control-row">
        <label for="bgContrast">Stripes contrast</label>
        <input id="bgContrast" type="range" min="0" max="100" value="20" />
        <span id="bgContrastVal" class="value">20%</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-underlay">
    <p class="kicker">Step 4 · Perspective underlay</p>
    <h2>Test Gregory’s 3‑D interpretation</h2>
    <p>Add an inside or outside corner to simulate depth. Tuning the opacity and vanishing-point exaggeration shows how implied 3‑D context modulates the illusion.</p>
    <div class="controls">
      <div class="control-row">
        <label for="underlay">Underlay type</label>
        <select id="underlay">
          <option value="none" selected>None</option>
          <option value="inside">Inside room corner</option>
          <option value="outside">Outside building corner</option>
        </select>
        <span class="value" aria-hidden="true"></span>
      </div>
      <div class="control-row">
        <label for="uAlpha">Underlay strength (opacity)</label>
        <input id="uAlpha" type="range" min="0" max="100" value="40" />
        <span id="uAlphaVal" class="value">40%</span>
      </div>
      <div class="control-row">
        <label for="uPersp">Perspective (vanishing) amount</label>
        <input id="uPersp" type="range" min="0" max="100" value="60" />
        <span id="uPerspVal" class="value">60%</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-top">
    <p class="kicker">Step 5 · Top figure</p>
    <h2>Shape the upper figure</h2>
    <p>Experiment with arrowheads, arrowtails, caps, circles, and feathered fins. Each option changes how far the endpoints feel from the shaft.</p>
    <div class="controls">
      <div class="control-row">
        <label for="topType">Configuration</label>
        <select id="topType">
          <option value="in">Wings-in (arrowheads)</option>
          <option value="out">Wings-out (tails)</option>
          <option value="caps">T-caps (90°)</option>
          <option value="circles">Circular end-caps</option>
          <option value="none">No ends (plain line)</option>
          <option value="feather">Feathered (multiple fins)</option>
        </select>
        <span class="value" aria-hidden="true"></span>
      </div>
      <div class="control-row">
        <label for="topLen">Shaft length (px)</label>
        <input id="topLen" type="range" min="60" max="800" value="420" />
        <span id="topLenVal" class="value">420</span>
      </div>
      <div class="control-row">
        <label for="topThick">Shaft thickness (px)</label>
        <input id="topThick" type="range" min="1" max="20" value="4" />
        <span id="topThickVal" class="value">4</span>
      </div>
      <div class="control-row">
        <label for="topAng">Wing angle (°)</label>
        <input id="topAng" type="range" min="15" max="165" value="45" />
        <span id="topAngVal" class="value">45°</span>
      </div>
      <div class="control-row">
        <label for="topWing">Wing length (px)</label>
        <input id="topWing" type="range" min="6" max="120" value="60" />
        <span id="topWingVal" class="value">60</span>
      </div>
      <div class="control-row">
        <label for="topWingTh">Wing thickness (px)</label>
        <input id="topWingTh" type="range" min="1" max="16" value="3" />
        <span id="topWingThVal" class="value">3</span>
      </div>
      <div class="control-row">
        <label for="topFeatherN">Feather fins (count)</label>
        <input id="topFeatherN" type="range" min="2" max="8" value="4" />
        <span id="topFeatherNVal" class="value">4</span>
      </div>
      <div class="control-row">
        <label for="topFeatherDx">Feather spacing (px)</label>
        <input id="topFeatherDx" type="range" min="4" max="30" value="12" />
        <span id="topFeatherDxVal" class="value">12</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-bottom">
    <p class="kicker">Step 6 · Bottom figure</p>
    <h2>Independently adjust the lower figure</h2>
    <p>Give the lower shaft its own configuration to create asymmetric pairs, or match the top for comparison. Try mixing feathers with plain lines.</p>
    <div class="controls">
      <div class="control-row">
        <label for="botType">Configuration</label>
        <select id="botType">
          <option value="out">Wings-out (tails)</option>
          <option value="in">Wings-in (arrowheads)</option>
          <option value="caps">T-caps (90°)</option>
          <option value="circles">Circular end-caps</option>
          <option value="none">No ends (plain line)</option>
          <option value="feather">Feathered (multiple fins)</option>
        </select>
        <span class="value" aria-hidden="true"></span>
      </div>
      <div class="control-row">
        <label for="botLen">Shaft length (px)</label>
        <input id="botLen" type="range" min="60" max="800" value="420" />
        <span id="botLenVal" class="value">420</span>
      </div>
      <div class="control-row">
        <label for="botThick">Shaft thickness (px)</label>
        <input id="botThick" type="range" min="1" max="20" value="4" />
        <span id="botThickVal" class="value">4</span>
      </div>
      <div class="control-row">
        <label for="botAng">Wing angle (°)</label>
        <input id="botAng" type="range" min="15" max="165" value="135" />
        <span id="botAngVal" class="value">135°</span>
      </div>
      <div class="control-row">
        <label for="botWing">Wing length (px)</label>
        <input id="botWing" type="range" min="6" max="120" value="60" />
        <span id="botWingVal" class="value">60</span>
      </div>
      <div class="control-row">
        <label for="botWingTh">Wing thickness (px)</label>
        <input id="botWingTh" type="range" min="1" max="16" value="3" />
        <span id="botWingThVal" class="value">3</span>
      </div>
      <div class="control-row">
        <label for="botFeatherN">Feather fins (count)</label>
        <input id="botFeatherN" type="range" min="2" max="8" value="4" />
        <span id="botFeatherNVal" class="value">4</span>
      </div>
      <div class="control-row">
        <label for="botFeatherDx">Feather spacing (px)</label>
        <input id="botFeatherDx" type="range" min="4" max="30" value="12" />
        <span id="botFeatherDxVal" class="value">12</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-overlays">
    <p class="kicker">Step 7 · Overlays & export</p>
    <h2>Toggle measurement aids and save the scene</h2>
    <p>Use ticks and bisection marks to prove the shafts are equal. Export a PNG or SVG when you want to capture a specific configuration.</p>
    <div class="controls">
      <div class="control-check">
        <input id="ticks" type="checkbox" checked />
        <label for="ticks">Show measuring ticks</label>
      </div>
      <div class="control-check">
        <input id="bisection" type="checkbox" />
        <label for="bisection">Show central bisection marks</label>
      </div>
      <div class="button-row">
        <button id="exportPng" class="btn" type="button">Export PNG</button>
        <button id="exportSvg" class="btn" type="button">Export SVG</button>
        <button id="reset" class="btn" type="button">Reset</button>
      </div>
      <div class="meter">
        <span class="badge" id="scoreTxt">—</span>
        <span id="why" class="control-note"></span>
      </div>
    </div>
  </section>
</main>
<script>
(() => {
  const $ = id => document.getElementById(id);
  const cv = $('cv'); const ctx = cv.getContext('2d');

  const ctl = {
    // global
    margin: $('margin'), colour:$('colour'), bgStripes:$('bgStripes'), bgContrast:$('bgContrast'),
    // underlay
    underlay:$('underlay'), uAlpha:$('uAlpha'), uPersp:$('uPersp'),
    // top
    topType:$('topType'), topLen:$('topLen'), topThick:$('topThick'), topAng:$('topAng'), topWing:$('topWing'), topWingTh:$('topWingTh'), topFeatherN:$('topFeatherN'), topFeatherDx:$('topFeatherDx'),
    // bottom
    botType:$('botType'), botLen:$('botLen'), botThick:$('botThick'), botAng:$('botAng'), botWing:$('botWing'), botWingTh:$('botWingTh'), botFeatherN:$('botFeatherN'), botFeatherDx:$('botFeatherDx'),
    // psychophysics
    lockEq:$('lockEq'), delta:$('delta'),
    // overlays
    ticks:$('ticks'), bisection:$('bisection')
  };
  const lab = {
    margin:$('marginVal'), bgContrast:$('bgContrastVal'),
    topLen:$('topLenVal'), topThick:$('topThickVal'), topAng:$('topAngVal'), topWing:$('topWingVal'), topWingTh:$('topWingThVal'), topFeatherN:$('topFeatherNVal'), topFeatherDx:$('topFeatherDxVal'),
    botLen:$('botLenVal'), botThick:$('botThickVal'), botAng:$('botAngVal'), botWing:$('botWingVal'), botWingTh:$('botWingThVal'), botFeatherN:$('botFeatherNVal'), botFeatherDx:$('botFeatherDxVal'),
    uAlpha:$('uAlphaVal'), uPersp:$('uPerspVal'), delta:$('deltaVal')
  };
  const scoreTxt = $('scoreTxt'), why = $('why');
  const pairPresetsEl = $('pairPresets');

  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const rect = cv.getBoundingClientRect();
    cv.width = Math.round(rect.width*dpr);
    cv.height = Math.round(rect.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  /* ---------- drawing primitives ---------- */
  function drawStripes(W,H,mode,contrast){
    if (mode==='none' || contrast<=0) return;
    const k = contrast/100; // 0..1
    const step = 16; // px
    ctx.save();
    ctx.globalAlpha = 0.25*k;
    ctx.fillStyle = '#000';
    if (mode==='parallel'){
      for (let x=0; x<W; x+=step*2){ ctx.fillRect(x,0,step,H);}    
    } else {
      for (let y=0; y<H; y+=step*2){ ctx.fillRect(0,y,W,step);}    
    }
    ctx.restore();
  }

  function drawUnderlay(W,H,type,alpha,persp){
    if (type==='none' || alpha<=0) return;
    const a = alpha/100, p = persp/100; // 0..1
    ctx.save(); ctx.globalAlpha = 0.5*a;
    // simple two-wall + floor or two-wall convex corner
    const cx=W/2, cy=H/2; const span = Math.min(W,H)*0.8;
    const h = cy; // horizon
    const vshift = (p*0.25*H);
    const vx1 = cx - span*(0.5+p*0.3), vx2 = cx + span*(0.5+p*0.3);
    if (type==='inside'){
      // three trapezoids: left wall, right wall, floor
      ctx.fillStyle = '#e7ecf7';
      ctx.beginPath(); ctx.moveTo(0,h-vshift); ctx.lineTo(cx, h); ctx.lineTo(cx, H); ctx.lineTo(0,H); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#f1f4fb';
      ctx.beginPath(); ctx.moveTo(W,h-vshift); ctx.lineTo(cx, h); ctx.lineTo(cx, H); ctx.lineTo(W,H); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#dfe6f3';
      ctx.beginPath(); ctx.moveTo(0,H); ctx.lineTo(W,H); ctx.lineTo(cx, h); ctx.lineTo(cx, h); ctx.closePath(); ctx.fill();
      // corner line
      ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,H); ctx.stroke();
    } else if (type==='outside'){
      // convex column (building corner) with two faces
      const colW = span*(0.12+0.18*p);
      ctx.fillStyle = '#e7ecf7'; ctx.fillRect(cx-colW/2,0,colW,H);
      ctx.fillStyle = '#f1f4fb'; ctx.fillRect(0,0,cx-colW/2,H);
      ctx.fillStyle = '#dfe6f3'; ctx.fillRect(cx+colW/2,0,W-(cx+colW/2),H);
      ctx.strokeStyle='rgba(0,0,0,0.15)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(cx-colW/2,0); ctx.lineTo(cx-colW/2,H); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx+colW/2,0); ctx.lineTo(cx+colW/2,H); ctx.stroke();
    }
    ctx.restore();
  }

  function drawTicks(x1,y, x2, colour){
    ctx.save(); ctx.strokeStyle = colour; ctx.lineWidth = 1; ctx.setLineDash([4,4]);
    ctx.beginPath(); ctx.moveTo(x1,y-12); ctx.lineTo(x1,y+12); ctx.moveTo(x2,y-12); ctx.lineTo(x2,y+12); ctx.stroke(); ctx.restore();
  }
  function drawBisection(x1,y, x2, colour){
    const xm = (x1+x2)/2; ctx.save(); ctx.strokeStyle=colour; ctx.lineWidth=1; ctx.setLineDash([6,6]);
    ctx.beginPath(); ctx.moveTo(xm,y-18); ctx.lineTo(xm,y+18); ctx.stroke(); ctx.restore();
  }

  function drawShaft(x1,y,x2,th,colour){ ctx.save(); ctx.strokeStyle = colour; ctx.lineWidth=th; ctx.beginPath(); ctx.moveTo(x1,y); ctx.lineTo(x2,y); ctx.stroke(); ctx.restore(); }

  function drawWing(endx, y, dir, type, angDeg, len, th, colour, featherN=4, featherDx=10){
    // dir: -1 for left end, +1 for right end. angDeg measured away from shaft direction.
    ctx.save(); ctx.strokeStyle = colour; ctx.lineWidth = th; ctx.lineCap='butt';
    if (type==='none') { ctx.restore(); return; }
    if (type==='circles'){
      ctx.beginPath(); ctx.arc(endx, y, Math.max(2, th*1.3), 0, Math.PI*2); ctx.stroke(); ctx.restore(); return;
    }
    const baseAng = 0; // shaft is horizontal
    let a = angDeg*Math.PI/180;
    if (type==='caps'){ a = Math.PI/2; }
    function lineAt(offset){
      // offset along shaft (positive inside the shaft), used for feathering
      const ex = endx + dir*offset;
      const a1 = baseAng + (dir>0? Math.PI - a : a);
      const a2 = baseAng + (dir>0? Math.PI + a : -a);
      const x1 = ex + Math.cos(a1)*len, y1 = y + Math.sin(a1)*len;
      const x2 = ex + Math.cos(a2)*len, y2 = y + Math.sin(a2)*len;
      ctx.beginPath(); ctx.moveTo(ex,y); ctx.lineTo(x1,y1); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ex,y); ctx.lineTo(x2,y2); ctx.stroke();
    }
    if (type==='feather'){
      for (let i=0;i<featherN;i++) lineAt(i*featherDx);
    } else {
      lineAt(0);
    }
    ctx.restore();
  }

  function drawFigure(cx, y, len, thick, type, ang, wingLen, wingTh, colour, featherN, featherDx, showTicks, showBisect){
    const x1 = cx - len/2, x2 = cx + len/2;
    drawShaft(x1,y,x2, thick, colour);
    drawWing(x1, y, -1, type, ang, wingLen, wingTh, colour, featherN, featherDx);
    drawWing(x2, y, +1, type, ang, wingLen, wingTh, colour, featherN, featherDx);
    if (showTicks) drawTicks(x1,y,x2, colour);
    if (showBisect) drawBisection(x1,y,x2, colour);
    return {x1,x2};
  }

  /* ---------- illusion score (rough) ---------- */
  function illusionScore(params){
    const {typeTop, typeBot, angTop, angBot, wingTop, wingBot, thickTop, thickBot, bg, underlay} = params;
    function fType(t){ return (t==='in'||t==='out') ? 1 : (t==='feather'?0.9:(t==='caps'?0.3:(t==='none'||t==='circles'?0:0.2))); }
    function fAng(a){ const d = Math.abs(90 - a)/90; return Math.min(1, 0.25 + d); } // away from 90° boosts
    function fWing(w){ return Math.min(1, w/60); }
    function fThick(t){ return Math.max(0.5, 1 - (t-4)/24); }
    function fBg(b){ return b==='none'?1:0.9; }
    function fU(u){ return u==='none'?1:1.05; } // underlay can slightly boost via interpretation
    const sTop = fType(typeTop)*fAng(angTop)*fWing(wingTop)*fThick(thickTop);
    const sBot = fType(typeBot)*fAng(angBot)*fWing(wingBot)*fThick(thickBot);
    const s = 100 * 0.5*(sTop+sBot) * fBg(bg) * fU(underlay);
    return Math.max(0, Math.min(100, s));
  }
  function whyText(p){
    const bits=[];
    if (!(p.typeTop==='in'||p.typeTop==='out'||p.typeBot==='in'||p.typeBot==='out')) bits.push('ends are non‑directional');
    if (Math.abs(p.angTop-90)<8 && Math.abs(p.angBot-90)<8) bits.push('wing angles near 90°');
    if (p.wingTop<12 && p.wingBot<12) bits.push('very short wings');
    if (p.thickTop>10 && p.thickBot>10) bits.push('very heavy shafts');
    if (bits.length===0) return 'Strong: directional wings, angles far from 90°, moderate wing length.';
    return 'Weakeners: ' + bits.join('; ') + '.';
  }

  /* ---------- presets ---------- */
  const pairPresets = [
    { id:'classic', name:'Classic (in vs out, equal length)', apply(){
        ctl.topType.value='in'; ctl.botType.value='out';
        ctl.topLen.value=420; ctl.botLen.value=420; ctl.lockEq.checked=true; ctl.delta.value=0;
        ctl.topAng.value=45; ctl.botAng.value=135; ctl.topWing.value=60; ctl.botWing.value=60; ctl.topThick.value=4; ctl.botThick.value=4; ctl.topWingTh.value=3; ctl.botWingTh.value=3;
        ctl.topFeatherN.value=4; ctl.botFeatherN.value=4; ctl.topFeatherDx.value=12; ctl.botFeatherDx.value=12;
        ctl.bgStripes.value='none'; ctl.underlay.value='none';
      }
    },
    { id:'extreme', name:'Extreme (long wings, steep angles)', apply(){
        ctl.topType.value='in'; ctl.botType.value='out';
        ctl.topLen.value=480; ctl.botLen.value=480; ctl.lockEq.checked=true; ctl.delta.value=0;
        ctl.topAng.value=25; ctl.botAng.value=155; ctl.topWing.value=110; ctl.botWing.value=110; ctl.topThick.value=3; ctl.botThick.value=3; ctl.topWingTh.value=2; ctl.botWingTh.value=2;
        ctl.bgStripes.value='parallel'; ctl.bgContrast.value=25; ctl.underlay.value='none';
      }
    },
    { id:'feather', name:'Feathered (many fins, strong)', apply(){
        ctl.topType.value='feather'; ctl.botType.value='feather';
        ctl.topLen.value=440; ctl.botLen.value=440; ctl.lockEq.checked=true; ctl.delta.value=0;
        ctl.topAng.value=35; ctl.botAng.value=145; ctl.topWing.value=70; ctl.botWing.value=70;
        ctl.topFeatherN.value=6; ctl.botFeatherN.value=6; ctl.topFeatherDx.value=10; ctl.botFeatherDx.value=10; ctl.topThick.value=4; ctl.botThick.value=4;
      }
    },
    { id:'caps', name:'T‑caps (near neutral)', apply(){
        ctl.topType.value='caps'; ctl.botType.value='caps'; ctl.topAng.value=90; ctl.botAng.value=90; ctl.topWing.value=50; ctl.botWing.value=50; ctl.topThick.value=5; ctl.botThick.value=5; ctl.lockEq.checked=true; ctl.delta.value=0;
      }
    },
    { id:'plain', name:'No illusion (plain lines)', apply(){
        ctl.topType.value='none'; ctl.botType.value='none'; ctl.topLen.value=420; ctl.botLen.value=420; ctl.lockEq.checked=true; ctl.delta.value=0; ctl.topThick.value=5; ctl.botThick.value=5;
      }
    },
    { id:'circles', name:'No illusion (circular end‑caps)', apply(){
        ctl.topType.value='circles'; ctl.botType.value='circles'; ctl.topLen.value=420; ctl.botLen.value=420; ctl.lockEq.checked=true; ctl.delta.value=0; ctl.topThick.value=5; ctl.botThick.value=5;
      }
    },
    { id:'gregory_inside', name:'Gregory: inside room corner', apply(){
        ctl.underlay.value='inside'; ctl.uAlpha.value=50; ctl.uPersp.value=70; ctl.topType.value='in'; ctl.botType.value='out'; ctl.lockEq.checked=true; ctl.delta.value=0;
      }
    },
    { id:'gregory_outside', name:'Gregory: outside building corner', apply(){
        ctl.underlay.value='outside'; ctl.uAlpha.value=50; ctl.uPersp.value=70; ctl.topType.value='in'; ctl.botType.value='out'; ctl.lockEq.checked=true; ctl.delta.value=0;
      }
    },
    { id:'bisection', name:'Bisection marks on (explanatory)', apply(){
        ctl.bisection.checked=true; ctl.ticks.checked=true; ctl.topType.value='in'; ctl.botType.value='out';
      }
    }
  ];

  function buildPairPresetButtons(){
    pairPresets.forEach(p=>{
      const b=document.createElement('button'); b.className='btn'; b.textContent=p.name; b.addEventListener('click', ()=>{ p.apply(); draw(); }); pairPresetsEl.appendChild(b);
    });
  }

  /* ---------- SVG export helpers ---------- */
  function svgEsc(s){ return String(s).replace(/[&<>]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c])); }

  function draw(){
    // labels
    lab.margin.textContent = ctl.margin.value; lab.bgContrast.textContent = ctl.bgContrast.value + '%';
    lab.topLen.textContent = ctl.topLen.value; lab.topThick.textContent=ctl.topThick.value; lab.topAng.textContent=ctl.topAng.value+'°'; lab.topWing.textContent=ctl.topWing.value; lab.topWingTh.textContent=ctl.topWingTh.value; lab.topFeatherN.textContent=ctl.topFeatherN.value; lab.topFeatherDx.textContent=ctl.topFeatherDx.value;
    lab.botLen.textContent = ctl.botLen.value; lab.botThick.textContent=ctl.botThick.value; lab.botAng.textContent=ctl.botAng.value+'°'; lab.botWing.textContent=ctl.botWing.value; lab.botWingTh.textContent=ctl.botWingTh.value; lab.botFeatherN.textContent=ctl.botFeatherN.value; lab.botFeatherDx.textContent=ctl.botFeatherDx.value;
    lab.uAlpha.textContent = ctl.uAlpha.value + '%'; lab.uPersp.textContent = ctl.uPersp.value + '%'; lab.delta.textContent = ctl.delta.value;

    const W=cv.width, H=cv.height; ctx.clearRect(0,0,W,H);

    // background assimilation stripes
    drawStripes(W,H, ctl.bgStripes.value, +ctl.bgContrast.value);

    // underlay
    drawUnderlay(W,H, ctl.underlay.value, +ctl.uAlpha.value, +ctl.uPersp.value);

    // positions
    const margin = +ctl.margin.value;
    const cx = W/2; const topY = Math.max(margin, H*0.35), botY = Math.min(H-margin, H*0.65);

    // lock lengths or apply delta
    let topLen = +ctl.topLen.value, botLen = +ctl.botLen.value;
    if (ctl.lockEq.checked){ botLen = topLen; topLen += +ctl.delta.value; } else { /* independent */ }

    const colour = ctl.colour.value;

    // draw top figure
    drawFigure(cx, topY, topLen, +ctl.topThick.value, ctl.topType.value, +ctl.topAng.value, +ctl.topWing.value, +ctl.topWingTh.value, colour, +ctl.topFeatherN.value, +ctl.topFeatherDx.value, ctl.ticks.checked, ctl.bisection.checked);

    // draw bottom figure
    drawFigure(cx, botY, botLen, +ctl.botThick.value, ctl.botType.value, +ctl.botAng.value, +ctl.botWing.value, +ctl.botWingTh.value, colour, +ctl.botFeatherN.value, +ctl.botFeatherDx.value, ctl.ticks.checked, ctl.bisection.checked);

    // score
    const s = illusionScore({ typeTop:ctl.topType.value, typeBot:ctl.botType.value, angTop:+ctl.topAng.value, angBot:+ctl.botAng.value, wingTop:+ctl.topWing.value, wingBot:+ctl.botWing.value, thickTop:+ctl.topThick.value, thickBot:+ctl.botThick.value, bg:ctl.bgStripes.value, underlay:ctl.underlay.value });
    scoreTxt.textContent = s.toFixed(0) + '/100';
    why.textContent = whyText({typeTop:ctl.topType.value, typeBot:ctl.botType.value, angTop:+ctl.topAng.value, angBot:+ctl.botAng.value, wingTop:+ctl.topWing.value, wingBot:+ctl.botWing.value, thickTop:+ctl.topThick.value, thickBot:+ctl.botThick.value});
  }

  // Export PNG
  $('exportPng').addEventListener('click', ()=>{
    const a=document.createElement('a'); a.download='muller-lyer.png'; a.href=cv.toDataURL('image/png'); a.click();
  });

  // Export SVG (vector of current scene sans underlay gradients/stripes)
  $('exportSvg').addEventListener('click', ()=>{
    const rect = cv.getBoundingClientRect(); const W=Math.round(rect.width), H=Math.round(rect.height);
    const margin = +ctl.margin.value; const cx=W/2; const topY=Math.max(margin, H*0.35), botY=Math.min(H-margin, H*0.65);
    let topLen=+ctl.topLen.value, botLen=+ctl.botLen.value; if (ctl.lockEq.checked){ botLen=topLen; topLen+= +ctl.delta.value; }
    const colour = ctl.colour.value;
    function wingPath(endx,y,dir,type,ang,len){
      if (type==='none') return '';
      if (type==='circles') return `<circle cx="${endx.toFixed(2)}" cy="${y.toFixed(2)}" r="${Math.max(2, +ctl.topWingTh.value*1.3)}" fill="none" stroke="${svgEsc(colour)}"/>`;
      const a=(type==='caps'?90:ang)*Math.PI/180; const a1 = (dir>0? Math.PI - a : a), a2 = (dir>0? Math.PI + a : -a);
      const x1=endx + Math.cos(a1)*len, y1=y + Math.sin(a1)*len; const x2=endx + Math.cos(a2)*len, y2=y + Math.sin(a2)*len;
      return `<path d="M ${endx.toFixed(2)} ${y.toFixed(2)} L ${x1.toFixed(2)} ${y1.toFixed(2)} M ${endx.toFixed(2)} ${y.toFixed(2)} L ${x2.toFixed(2)} ${y2.toFixed(2)}" stroke="${svgEsc(colour)}" fill="none"/>`;
    }
    function fig(y, len, type, ang, wing, thick){
      const x1=cx-len/2, x2=cx+len/2; return [
        `<line x1="${x1.toFixed(2)}" y1="${y.toFixed(2)}" x2="${x2.toFixed(2)}" y2="${y.toFixed(2)}" stroke="${svgEsc(colour)}" stroke-width="${thick}"/>`,
        wingPath(x1,y,-1,type,ang,wing), wingPath(x2,y,+1,type,ang,wing)
      ].join('\n');
    }
    const parts=[`<rect x="0" y="0" width="${W}" height="${H}" fill="#ffffff"/>`, fig(topY, topLen, ctl.topType.value, +ctl.topAng.value, +ctl.topWing.value, +ctl.topThick.value), fig(botY, botLen, ctl.botType.value, +ctl.botAng.value, +ctl.botWing.value, +ctl.botThick.value)];
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">\n${parts.join('\n')}\n</svg>`;
    const blob=new Blob([svg],{type:'image/svg+xml'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='muller-lyer.svg'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),2000);
  });

  $('reset').addEventListener('click', ()=>{ pairPresets[0].apply(); draw(); });

  function bindInputs(){
    document.querySelectorAll('input,select').forEach(inp=>{
      const ev = (inp.tagName==='SELECT'||inp.type==='checkbox')?'change':'input';
      inp.addEventListener(ev, draw, {passive:true});
    });
    window.addEventListener('resize', ()=>{ fitCanvas(); draw(); }, {passive:true});
  }

  function init(){
    fitCanvas(); buildPairPresetButtons(); bindInputs(); pairPresets[0].apply(); draw();
  }
  init();
})();
</script>
</body>
</html>
