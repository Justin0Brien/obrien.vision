<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Motion Aftereffect (Waterfall) — step-by-step lab</title>
<link rel="stylesheet" href="../assets/css/illusion-demo.css" />
<style>
  .mae-surface { position: relative; }
  .mae-surface canvas { --demo-aspect: 1 / 1; }
  .mae-overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .mae-overlay .bubble{background:rgba(0,0,0,0.65); color:#fff; padding:10px 14px; border-radius:10px; font-weight:600; letter-spacing:.3px}
  .progress{height:8px;border-radius:6px;background:#e5e7eb; overflow:hidden}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,#60a5fa,#2563eb);width:0%}
  .badge{display:inline-block;background:#eef2ff;color:#3730a3;border-radius:8px;padding:2px 8px;font-size:12px}
</style>
</head>
<body>
<main class="illusion-page">
  <section class="hero">
    <p class="kicker">Motion aftereffect</p>
    <h1>Trigger the waterfall illusion with a single adaptation run</h1>
    <p class="lede">Stare at moving texture and the static test will drift the other way. Press start, fixate the cross, then scroll down to fine-tune every detail of the lab.</p>
    <div class="demo-frame">
      <p class="kicker">Live canvas</p>
      <div class="demo-surface mae-surface">
        <canvas id="cv" aria-label="Motion aftereffect canvas"></canvas>
        <div class="mae-overlay" id="overlay" aria-hidden="true" style="display:none"><div class="bubble" id="overlayTxt">Fixate the +</div></div>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-run-basic">
    <p class="kicker">Step 1 · Adaptation run</p>
    <h2>Start the timer and keep your eyes on the cross</h2>
    <p>Press start to begin the adaptation phase. The progress bar shows elapsed time and the label reports the current state.</p>
    <div class="controls">
      <div class="button-row">
        <button id="start" class="btn" type="button">Start adapting</button>
      </div>
      <div class="control-row">
        <label for="stateTxt">State</label>
        <div class="progress"><i id="prog" style="width:0%"></i></div>
        <span id="stateTxt" class="value badge">idle</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-run-advanced">
    <p class="kicker">Step 2 · Advanced run controls</p>
    <h2>Top up, jump to test, or abort early</h2>
    <p>Once you understand the cycle, use these buttons to manage quick demonstrations: top up the adaptation, skip straight to the test, or halt the sequence.</p>
    <div class="controls">
      <div class="button-row">
        <button id="topup" class="btn" type="button">Top‑up 2 s</button>
        <button id="toTest" class="btn" type="button">Go to test</button>
        <button id="stop" class="btn" type="button">Stop</button>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-adapt">
    <p class="kicker">Step 3 · Adapting stimulus</p>
    <h2>Pick the moving pattern that drives adaptation</h2>
    <p>Choose gratings, rotating dots, or expanding fields, then set motion strength, speed, and contrast. Fixation helps the effect accumulate.</p>
    <div class="controls">
      <div class="control-row">
        <label for="adaptType">Type</label>
        <select id="adaptType">
          <option value="gratingH">Drifting grating (→/←)</option>
          <option value="gratingV">Drifting grating (↑/↓)</option>
          <option value="rotation">Dot field rotation (CW/CCW)</option>
          <option value="radial">Dot field expansion/contraction</option>
        </select>
        <span class="value" aria-hidden="true"></span>
      </div>
      <div class="control-row">
        <label for="direction">Direction</label>
        <select id="direction">
          <option value="forward">Forward (e.g., →, CW, expand)</option>
          <option value="reverse">Reverse (e.g., ←, CCW, contract)</option>
        </select>
        <span class="value" aria-hidden="true"></span>
      </div>
      <div class="control-row">
        <label for="adaptTime">Adaptation time (s)</label>
        <input id="adaptTime" type="range" min="2" max="30" value="12" />
        <span id="adaptTimeVal" class="value">12</span>
      </div>
      <div class="control-row">
        <label for="speed">Speed (a.u.)</label>
        <input id="speed" type="range" min="0.1" max="8" step="0.1" value="2.5" />
        <span id="speedVal" class="value">2.5</span>
      </div>
      <div class="control-row">
        <label for="sf">Spatial frequency (cycles)</label>
        <input id="sf" type="range" min="2" max="40" value="12" />
        <span id="sfVal" class="value">12</span>
      </div>
      <div class="control-row">
        <label for="contrast">Contrast</label>
        <input id="contrast" type="range" min="5" max="100" value="90" />
        <span id="contrastVal" class="value">90%</span>
      </div>
      <div class="control-row">
        <label for="dots">Dot count (for dot fields)</label>
        <input id="dots" type="range" min="100" max="2000" step="50" value="800" />
        <span id="dotsVal" class="value">800</span>
      </div>
      <div class="control-check">
        <input id="fixation" type="checkbox" checked />
        <label for="fixation">Fixation cross</label>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-test">
    <p class="kicker">Step 4 · Test stimulus</p>
    <h2>Select the static pattern used for the aftereffect</h2>
    <p>Swap the stationary test between gratings, rings, noise, or blank mid-grey, and adjust its contrast. You can even show a faint test during adaptation.</p>
    <div class="controls">
      <div class="control-row">
        <label for="testType">Type</label>
        <select id="testType">
          <option value="gratingH">Stationary grating (horizontal)</option>
          <option value="gratingV">Stationary grating (vertical)</option>
          <option value="rings">Stationary radial rings</option>
          <option value="noise">Static noise</option>
          <option value="blank">Blank mid-grey</option>
        </select>
        <span class="value" aria-hidden="true"></span>
      </div>
      <div class="control-row">
        <label for="testContrast">Test contrast</label>
        <input id="testContrast" type="range" min="5" max="100" value="70" />
        <span id="testContrastVal" class="value">70%</span>
      </div>
      <div class="control-check">
        <input id="ghostTest" type="checkbox" />
        <label for="ghostTest">Show during adaptation</label>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-presets">
    <p class="kicker">Step 5 · Presets</p>
    <h2>Jump to lab-tested combinations</h2>
    <p>Use presets for quick demonstrations: classic waterfall, strong rotation, low contrast, and more.</p>
    <div class="controls">
      <div id="presetRow" class="button-row presets"></div>
    </div>
  </section>

  <section class="stage" id="stage-export">
    <p class="kicker">Step 6 · Export & reset</p>
    <h2>Capture the current frame or restore defaults</h2>
    <p>Grab a PNG for lectures or reset everything before a new participant takes the test.</p>
    <div class="controls">
      <div class="button-row">
        <button id="exportPng" class="btn" type="button">Export PNG</button>
        <button id="reset" class="btn" type="button">Reset</button>
      </div>
    </div>
  </section>
</main>
<script>
(() => {
  const $ = id => document.getElementById(id);
  const cv = $('cv'), ctx = cv.getContext('2d');

  const ctl = {
    adaptType:$('adaptType'), direction:$('direction'), adaptTime:$('adaptTime'), speed:$('speed'), sf:$('sf'), contrast:$('contrast'), dots:$('dots'), fixation:$('fixation'),
    testType:$('testType'), testContrast:$('testContrast'), ghostTest:$('ghostTest')
  };
  const lab = { adaptTime:$('adaptTimeVal'), speed:$('speedVal'), sf:$('sfVal'), contrast:$('contrastVal'), dots:$('dotsVal'), testContrast:$('testContrastVal') };
  const prog = $('prog'), stateTxt = $('stateTxt'), overlay = $('overlay'), overlayTxt = $('overlayTxt');

  const state = {
    mode:'idle', // 'adapt' | 'test' | 'idle'
    t0: 0, t: 0,
    phase: 0, // for grating
    rot: 0, // rotation angle
    dots: [],
    timerEnd: 0,
  };

  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const rect = cv.getBoundingClientRect();
    cv.width = Math.round(rect.width*dpr);
    cv.height = Math.round(rect.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  /* ---------- helpers ---------- */
  function greyFromContrast(base, c){
    // base is 0..1 mid-grey 0.5; c is 0..100
    const k = c/100; const lo = 0.5 - 0.5*k, hi = 0.5 + 0.5*k;
    return {lo:lo, hi:hi};
  }
  function toHex01(v){ const x = Math.round(Math.min(1,Math.max(0,v))*255); const h=x.toString(16).padStart(2,'0'); return `#${h}${h}${h}`; }

  /* ---------- patterns ---------- */
  function drawGrating(dir, phase, cycles, contrast, ghost=0){
    const W=cv.width, H=cv.height; const g=greyFromContrast(0.5, contrast); const lo=toHex01(g.lo), hi=toHex01(g.hi);
    const isH = (dir==='H');
    const len = isH? W : H; const period = len/Math.max(1,cycles);
    ctx.save(); ctx.fillStyle = toHex01(0.5); ctx.fillRect(0,0,W,H);
    ctx.fillStyle = hi; ctx.strokeStyle = hi;
    const shift = ((phase%period)+period)%period; // 0..period
    if (isH){
      for (let x=-period+shift; x<W; x+=period){ ctx.fillRect(x,0,period/2,H); }
    } else {
      for (let y=-period+shift; y<H; y+=period){ ctx.fillRect(0,y,W,period/2); }
    }
    // if ghost test requested, faintly show the static test overlay
    if (ghost>0) drawTestStim(ctl.testType.value, +ctl.testContrast.value, ghost);
    // fixation
    if (ctl.fixation.checked) drawFixation();
    ctx.restore();
  }

  function ensureDots(n){
    const W=cv.width, H=cv.height; const cx=W/2, cy=H/2; const need=n - state.dots.length; if (need<=0) return;
    for (let i=0;i<need;i++){
      const r = Math.random()*Math.min(W,H)*0.48; const ang = Math.random()*Math.PI*2;
      state.dots.push({r, ang});
    }
  }

  function drawRotatingDots(clockwise, speed, contrast){
    const W=cv.width, H=cv.height; const cx=W/2, cy=H/2; const g=greyFromContrast(0.5, contrast); const lo=toHex01(g.lo), hi=toHex01(g.hi);
    ctx.fillStyle = toHex01(0.5); ctx.fillRect(0,0,W,H);
    ensureDots(+ctl.dots.value);
    const s = (clockwise? 1:-1) * speed * 0.015; // radians per frame-ish
    state.rot += s;
    ctx.fillStyle = hi;
    for (const d of state.dots){
      const a = d.ang + state.rot; const x = cx + Math.cos(a)*d.r; const y = cy + Math.sin(a)*d.r;
      ctx.beginPath(); ctx.arc(x,y,2.2,0,Math.PI*2); ctx.fill();
    }
    if (ctl.ghostTest.checked) drawTestStim(ctl.testType.value, +ctl.testContrast.value, 0.12);
    if (ctl.fixation.checked) drawFixation();
  }

  function drawRadialDots(expand, speed, contrast){
    const W=cv.width, H=cv.height; const cx=W/2, cy=H/2; const g=greyFromContrast(0.5, contrast); const hi=toHex01(g.hi);
    ctx.fillStyle = toHex01(0.5); ctx.fillRect(0,0,W,H);
    ensureDots(+ctl.dots.value);
    const v = (expand? 1:-1) * speed * 0.45; // px per frame-ish
    const Rmax = Math.min(W,H)*0.5; const Rmin = 6;
    ctx.fillStyle = hi;
    for (const d of state.dots){
      d.r += v;
      if (d.r>Rmax) d.r = Rmin;
      if (d.r<Rmin) d.r = Rmax;
      const x = cx + Math.cos(d.ang)*d.r; const y = cy + Math.sin(d.ang)*d.r;
      ctx.beginPath(); ctx.arc(x,y,2,0,Math.PI*2); ctx.fill();
    }
    if (ctl.ghostTest.checked) drawTestStim(ctl.testType.value, +ctl.testContrast.value, 0.12);
    if (ctl.fixation.checked) drawFixation();
  }

  function drawFixation(){
    const W=cv.width, H=cv.height; const cx=W/2, cy=H/2;
    ctx.save(); ctx.strokeStyle='#111'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(cx-10,cy); ctx.lineTo(cx+10,cy); ctx.moveTo(cx,cy-10); ctx.lineTo(cx,cy+10); ctx.stroke(); ctx.restore();
  }

  /* ---------- test stimuli (static) ---------- */
  function drawTestStim(type, contrast, ghostAlpha=0){
    const W=cv.width, H=cv.height; const g=greyFromContrast(0.5, contrast); const lo=toHex01(g.lo), hi=toHex01(g.hi);
    if (ghostAlpha>0) { ctx.save(); ctx.globalAlpha = ghostAlpha; }
    if (type==='blank'){
      ctx.fillStyle = toHex01(0.5); ctx.fillRect(0,0,W,H);
    } else if (type==='gratingH'){
      ctx.fillStyle = toHex01(0.5); ctx.fillRect(0,0,W,H);
      const cycles = +ctl.sf.value; const len=W; const period=len/Math.max(1,cycles);
      ctx.fillStyle=hi; for (let x=0;x<W;x+=period){ ctx.fillRect(x,0,period/2,H); }
    } else if (type==='gratingV'){
      ctx.fillStyle = toHex01(0.5); ctx.fillRect(0,0,W,H);
      const cycles = +ctl.sf.value; const len=H; const period=len/Math.max(1,cycles);
      ctx.fillStyle=hi; for (let y=0;y<H;y+=period){ ctx.fillRect(0,y,W,period/2); }
    } else if (type==='rings'){
      ctx.fillStyle = toHex01(0.5); ctx.fillRect(0,0,W,H);
      const cx=W/2, cy=H/2; const Rmax=Math.min(W,H)*0.5; const n=+ctl.sf.value*0.8; ctx.strokeStyle=hi; ctx.lineWidth=2;
      for (let i=1;i<=n;i++){ const r=i*Rmax/n; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke(); }
    } else if (type==='noise'){
      const d = ctx.createImageData(W,H); const k = (contrast/100);
      for (let i=0;i<d.data.length;i+=4){ const v = Math.round((0.5 + (Math.random()*2-1)*0.5*k)*255); d.data[i]=d.data[i+1]=d.data[i+2]=v; d.data[i+3]=255; }
      ctx.putImageData(d,0,0);
    }
    if (ghostAlpha>0) { if (ctl.fixation.checked) drawFixation(); ctx.restore(); }
  }

  /* ---------- run loop ---------- */
  let raf=null, last=0;
  function loop(ts){
    if (!last) last=ts; const dt = Math.min(1/30,(ts-last)/1000); last=ts; // cap dt
    state.t += dt;

    // labels
    lab.adaptTime.textContent = ctl.adaptTime.value;
    lab.speed.textContent = ctl.speed.value;
    lab.sf.textContent = ctl.sf.value;
    lab.contrast.textContent = ctl.contrast.value+'%';
    lab.dots.textContent = ctl.dots.value;
    lab.testContrast.textContent = ctl.testContrast.value+'%';

    const mode = state.mode;
    if (mode==='adapt'){
      overlay.style.display='flex'; overlayTxt.textContent='Fixate the +';
      const leftTo = Math.max(0, state.timerEnd - performance.now());
      const frac = 1 - (leftTo / (+ctl.adaptTime.value*1000));
      prog.style.width = Math.max(0, Math.min(100, frac*100)) + '%';
      stateTxt.textContent = 'adapting';

      const sp = +ctl.speed.value; const dirF = (ctl.direction.value==='forward')? 1 : -1;
      if (ctl.adaptType.value==='gratingH'){
        state.phase += dirF * sp * 4 * dt;
        drawGrating('H', state.phase * (cv.width/Math.max(1,+ctl.sf.value)), +ctl.sf.value, +ctl.contrast.value, ctl.ghostTest.checked? 0.12:0);
      } else if (ctl.adaptType.value==='gratingV'){
        state.phase += dirF * sp * 4 * dt;
        drawGrating('V', state.phase * (cv.height/Math.max(1,+ctl.sf.value)), +ctl.sf.value, +ctl.contrast.value, ctl.ghostTest.checked? 0.12:0);
      } else if (ctl.adaptType.value==='rotation'){
        drawRotatingDots(dirF>0, +ctl.speed.value, +ctl.contrast.value);
      } else if (ctl.adaptType.value==='radial'){
        drawRadialDots(dirF>0, +ctl.speed.value, +ctl.contrast.value);
      }

      if (leftTo <= 0){ toTest(); }
    }
    else if (mode==='test'){
      overlay.style.display='flex'; overlayTxt.textContent='Now the static test should drift opposite';
      prog.style.width = '100%'; stateTxt.textContent = 'test';
      drawTestStim(ctl.testType.value, +ctl.testContrast.value, 0);
      if (ctl.fixation.checked) drawFixation();
    } else {
      overlay.style.display='none'; prog.style.width='0%'; stateTxt.textContent='idle';
      drawTestStim('blank', 50, 0); if (ctl.fixation.checked) drawFixation();
    }

    raf = requestAnimationFrame(loop);
  }

  /* ---------- controls ---------- */
  function startAdapt(extra=0){
    state.mode='adapt'; state.t=0; last=0; state.phase=0; state.rot=0; if (extra===0) state.dots=[];
    const ms = (+ctl.adaptTime.value + extra)*1000; state.timerEnd = performance.now() + ms;
  }
  function toTest(){ state.mode='test'; }
  function stopAll(){ state.mode='idle'; }

  $('start').addEventListener('click', ()=> startAdapt(0));
  $('topup').addEventListener('click', ()=> startAdapt(-(+ctl.adaptTime.value) + 2)); // 2 s top-up
  $('toTest').addEventListener('click', ()=> toTest());
  $('stop').addEventListener('click', ()=> stopAll());
  $('reset').addEventListener('click', ()=>{ stopAll(); ctl.adaptType.value='gratingV'; ctl.direction.value='forward'; ctl.adaptTime.value=12; ctl.speed.value=2.5; ctl.sf.value=12; ctl.contrast.value=90; ctl.testType.value='gratingV'; ctl.testContrast.value=70; ctl.dots.value=800; ctl.fixation.checked=true; ctl.ghostTest.checked=false; drawTestStim('blank', 50, 0); });

  // export PNG
  $('exportPng').addEventListener('click', ()=>{ const a=document.createElement('a'); a.download='mae.png'; a.href=cv.toDataURL('image/png'); a.click(); });

  // presets
  const presets = [
    {id:'classic', name:'Classic waterfall', apply(){
      ctl.adaptType.value='gratingV'; ctl.direction.value='forward'; // downward motion
      ctl.testType.value='gratingV'; ctl.sf.value=14; ctl.speed.value=2.2; ctl.contrast.value=95; ctl.testContrast.value=70; ctl.adaptTime.value=12; ctl.ghostTest.checked=false; ctl.fixation.checked=true;
    }},
    {id:'rotation', name:'Strong rotation', apply(){
      ctl.adaptType.value='rotation'; ctl.direction.value='forward'; ctl.speed.value=3.2; ctl.contrast.value=95; ctl.adaptTime.value=15; ctl.testType.value='rings'; ctl.testContrast.value=80; ctl.sf.value=14;
    }},
    {id:'radial', name:'Strong expansion', apply(){
      ctl.adaptType.value='radial'; ctl.direction.value='forward'; ctl.speed.value=2.8; ctl.contrast.value=90; ctl.dots.value=1200; ctl.adaptTime.value=12; ctl.testType.value='rings'; ctl.testContrast.value=80; ctl.sf.value=12;
    }},
    {id:'weak', name:'Weak (low contrast)', apply(){
      ctl.adaptType.value='gratingH'; ctl.direction.value='forward'; ctl.speed.value=1.0; ctl.contrast.value=25; ctl.adaptTime.value=6; ctl.testType.value='gratingH'; ctl.testContrast.value=40; ctl.sf.value=10;
    }},
    {id:'noMAE', name:'No MAE (no adaptation)', apply(){
      stopAll(); ctl.testType.value='gratingV'; ctl.testContrast.value=70; ctl.sf.value=12; overlay.style.display='none';
    }},
  ];

  const presetRow = $('presetRow');
  presets.forEach(p=>{ const b=document.createElement('button'); b.className='btn'; b.textContent=p.name; b.addEventListener('click', ()=>{ p.apply(); drawTestStim('blank',50,0); }); presetRow.appendChild(b); });

  // wire labels
  function bind(){
    document.querySelectorAll('input,select').forEach(inp=>{
      const ev = (inp.tagName==='SELECT'||inp.type==='checkbox') ? 'change' : 'input';
      inp.addEventListener(ev, ()=>{ lab.adaptTime.textContent=ctl.adaptTime.value; lab.speed.textContent=ctl.speed.value; lab.sf.textContent=ctl.sf.value; lab.contrast.textContent=ctl.contrast.value+'%'; lab.dots.textContent=ctl.dots.value; lab.testContrast.textContent=ctl.testContrast.value+'%'; }, {passive:true});
    });
  }

  function init(){
    fitCanvas(); window.addEventListener('resize', ()=>{ fitCanvas(); }, {passive:true}); bind(); presets[0].apply(); drawTestStim('blank',50,0); raf=requestAnimationFrame(loop);
  }
  init();
})();
</script>
</body>
</html>
