---
layout: null
permalink: /illusions/hermann-grid.html
---
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interactive Hermann Grid — mobile-first walkthrough</title>
<link rel="stylesheet" href="../assets/css/illusion-demo.css" />
<style>
  .demo-surface canvas { --demo-aspect: 1 / 1; }
</style>
</head>
<body>
<main class="illusion-page">
  <section class="hero">
    <p class="kicker">Hermann grid illusion</p>
    <h1>Watch grey smudges appear where bright streets cross</h1>
    <p class="lede">The Hermann grid produces phantom dark spots at intersections when your retina adapts to high-contrast “streets”. Begin by narrowing the streets, then scroll to expand the full lab.</p>
    <div class="demo-frame">
      <p class="kicker">Live canvas</p>
      <div class="demo-surface">
        <canvas id="cv" aria-label="Hermann Grid canvas"></canvas>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-street">
    <p class="kicker">Step 1 · Street width</p>
    <h2>Make the white streets narrow or wide</h2>
    <p>Thin white corridors between black squares trigger the strongest grey blobs. Widen the streets and the illusion fades away.</p>
    <div class="controls">
      <div class="control-row">
        <label for="street">Street width (px)</label>
        <input id="street" type="range" min="6" max="40" value="22" />
        <span id="streetVal" class="value">22</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-contrast">
    <p class="kicker">Step 2 · Contrast</p>
    <h2>Dial in the dark square levels or invert the entire grid</h2>
    <p>High contrast exaggerates the response from retinal ganglion cells. Softening the dark squares or inverting the palette lets you test how polarity influences the effect.</p>
    <div class="controls">
      <div class="control-row">
        <label for="dark">Square darkness</label>
        <input id="dark" type="range" min="0" max="100" value="100" />
        <span id="darkVal" class="value">100%</span>
      </div>
      <div class="control-check">
        <input id="invert" type="checkbox" />
        <label for="invert">Invert colours</label>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-geometry">
    <p class="kicker">Step 3 · Geometry</p>
    <h2>Control the grid size and the corners</h2>
    <p>More cells create more intersections to explore. Slight corner rounding morphs the illusion toward the Scintillating Grid variant.</p>
    <div class="controls">
      <div class="control-row">
        <label for="cells">Cells per row/column</label>
        <input id="cells" type="range" min="3" max="20" value="8" />
        <span id="cellsVal" class="value">8</span>
      </div>
      <div class="control-row">
        <label for="sq">Square size (px)</label>
        <input id="sq" type="range" min="18" max="120" value="64" />
        <span id="sqVal" class="value">64</span>
      </div>
      <div class="control-row">
        <label for="round">Corner rounding (px)</label>
        <input id="round" type="range" min="0" max="24" value="0" />
        <span id="roundVal" class="value">0</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-extras">
    <p class="kicker">Step 4 · Extras</p>
    <h2>Add blur or scintillating dots</h2>
    <p>Soft defocus mimics viewing the grid slightly out of focus. Adding small white dots at intersections morphs the classic illusion into its scintillating cousin.</p>
    <div class="controls">
      <div class="control-row">
        <label for="blur">Blur (defocus, px)</label>
        <input id="blur" type="range" min="0" max="4" step="0.2" value="0" />
        <span id="blurVal" class="value">0.0</span>
      </div>
      <div class="control-check">
        <input id="dots" type="checkbox" />
        <label for="dots">Show “scintillating” dots</label>
      </div>
      <div class="control-row">
        <label for="dotR">Dot radius (px)</label>
        <input id="dotR" type="range" min="2" max="14" value="6" />
        <span id="dotRVal" class="value">6</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-presets">
    <p class="kicker">Step 5 · Presets & export</p>
    <h2>Jump to proven configurations or save a snapshot</h2>
    <p>Use presets to demonstrate strong and weak variants in class, then export a PNG or SVG when you find a setup you like.</p>
    <div class="controls">
      <div id="paramPresets" class="button-row presets"></div>
      <div class="button-row">
        <button id="exportPng" class="btn" type="button">Export PNG</button>
        <button id="exportSvg" class="btn" type="button">Export SVG</button>
        <button id="reset" class="btn" type="button">Reset</button>
      </div>
    </div>
  </section>
</main>
<script>
(() => {
  const $ = id => document.getElementById(id);
  const cv = $('cv'); const ctx = cv.getContext('2d');

  const ctl = {
    cells:$('cells'), sq:$('sq'), street:$('street'), round:$('round'),
    dark:$('dark'), invert:$('invert'),
    blur:$('blur'), dots:$('dots'), dotR:$('dotR')
  };
  const labels = {
    cells:$('cellsVal'), sq:$('sqVal'), street:$('streetVal'), round:$('roundVal'),
    dark:$('darkVal'), blur:$('blurVal'), dotR:$('dotRVal')
  };

  /* ---------- canvas sizing ---------- */
  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const rect = cv.getBoundingClientRect();
    cv.width = Math.round(rect.width*dpr);
    cv.height = Math.round(rect.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  /* ---------- helpers ---------- */
  function shadeFromDarkness(pct){
    // 0..100; 100 = black, 0 = very light grey (not pure white, to leave some contrast when inverted)
    const v = Math.round(255 * (1 - pct/100) * 0.7);
    const hex = v.toString(16).padStart(2,'0');
    return `#${hex}${hex}${hex}`;
  }
  function clamp(v,a,b){ return Math.min(b, Math.max(a, v)); }

  /* ---------- drawing ---------- */
  function draw(){
    // labels
    labels.cells.textContent = ctl.cells.value;
    labels.sq.textContent    = ctl.sq.value;
    labels.street.textContent= ctl.street.value;
    labels.round.textContent = ctl.round.value;
    labels.dark.textContent  = ctl.dark.value + '%';
    labels.blur.textContent  = (+ctl.blur.value).toFixed(1);
    labels.dotR.textContent  = ctl.dotR.value;

    // blur filter on canvas element (preview only; not used in exports)
    cv.style.filter = ctl.blur.value > 0 ? `blur(${ctl.blur.value}px)` : 'none';

    const N       = +ctl.cells.value;
    const S       = +ctl.sq.value;      // square size
    const W       = +ctl.street.value;  // street width
    const R       = +ctl.round.value;   // corner radius
    const DOTS    = ctl.dots.checked;
    const DOTR    = +ctl.dotR.value;

    const darkHex = shadeFromDarkness(+ctl.dark.value);
    const sqCol   = ctl.invert.checked ? '#ffffff' : darkHex;
    const bgCol   = ctl.invert.checked ? darkHex : '#ffffff';

    const totalW = N*S + (N-1)*W;
    const totalH = totalW;
    const Wc = cv.width, Hc = cv.height;

    ctx.clearRect(0,0,Wc,Hc);
    ctx.save();
    ctx.translate(Wc/2, Hc/2);

    // background
    ctx.fillStyle = bgCol;
    ctx.fillRect(-Wc/2, -Hc/2, Wc, Hc);

    // draw squares
    ctx.fillStyle = sqCol;
    const startX = -totalW/2, startY = -totalH/2;
    for (let r=0; r<N; r++){
      for (let c=0; c<N; c++){
        const x = startX + c*(S+W);
        const y = startY + r*(S+W);
        roundRect(ctx, x, y, S, S, clamp(R, 0, S/2));
        ctx.fill();
      }
    }

    // optional scintillating dots at intersections (centre of “streets”)
    if (DOTS){
      ctx.fillStyle = ctl.invert.checked ? darkHex : '#ffffff';
      for (let r=0; r<N-1; r++){
        for (let c=0; c<N-1; c++){
          const cx = startX + (c+1)*S + c*W + W/2;
          const cy = startY + (r+1)*S + r*W + W/2;
          ctx.beginPath();
          ctx.arc(cx, cy, DOTR, 0, Math.PI*2);
          ctx.closePath();
          ctx.fill();
        }
      }
    }

    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.lineTo(x+w-rr, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
    ctx.lineTo(x+w, y+h-rr);
    ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    ctx.lineTo(x+rr, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
    ctx.lineTo(x, y+rr);
    ctx.quadraticCurveTo(x, y, x+rr, y);
    ctx.closePath();
  }

  /* ---------- presets ---------- */
  const paramPresets = [
    { id:'classicStrong', name:'Classic (strong)',
      cells:8, sq:64, street:22, round:0, dark:100, invert:false, blur:0.0, dots:false, dotR:6 },
    { id:'widerStreets',  name:'Wide streets',
      cells:7, sq:60, street:28, round:0, dark:100, invert:false, blur:0.0, dots:false, dotR:6 },
    { id:'roundedWeak',   name:'Rounded (weak)',
      cells:8, sq:64, street:22, round:16, dark:100, invert:false, blur:0.0, dots:false, dotR:6 },
    { id:'denseSmall',    name:'Dense & small',
      cells:12, sq:36, street:16, round:0, dark:100, invert:false, blur:0.0, dots:false, dotR:5 },
    { id:'lowContrast',   name:'Lower contrast',
      cells:8, sq:64, street:22, round:0, dark:65, invert:false, blur:0.0, dots:false, dotR:6 },
    { id:'inverted',      name:'Inverted',
      cells:8, sq:64, street:22, round:0, dark:100, invert:true,  blur:0.0, dots:false, dotR:6 },
    { id:'scintOverlay',  name:'Scintillating overlay',
      cells:9, sq:52, street:18, round:0, dark:100, invert:false, blur:0.0, dots:true,  dotR:6 },
  ];
  const presetRow = $('paramPresets');

  function applyPreset(p){
    ctl.cells.value = p.cells; ctl.sq.value = p.sq; ctl.street.value = p.street; ctl.round.value = p.round;
    ctl.dark.value  = p.dark;  ctl.invert.checked = !!p.invert;
    ctl.blur.value  = p.blur;  ctl.dots.checked  = !!p.dots; ctl.dotR.value = p.dotR;
    markActivePreset(p.id);
    draw();
  }
  function buildPresetButtons(){
    paramPresets.forEach(p=>{
      const b = document.createElement('button');
      b.className = 'btn';
      b.textContent = p.name;
      b.dataset.pid = p.id;
      b.type = 'button';
      b.addEventListener('click', ()=> applyPreset(p));
      presetRow.appendChild(b);
    });
    markActivePreset('classicStrong');
  }
  function markActivePreset(id){
    [...presetRow.querySelectorAll('button')].forEach(b=>{
      const on = b.dataset.pid === id;
      b.classList.toggle('active', on);
      b.setAttribute('aria-pressed', on ? 'true' : 'false');
    });
  }

  /* ---------- export ---------- */
  $('exportPng').addEventListener('click', ()=>{
    // Temporarily disable blur for a crisp export
    const oldFilter = cv.style.filter;
    cv.style.filter = 'none';
    const a=document.createElement('a');
    a.download='hermann-grid.png';
    a.href=cv.toDataURL('image/png');
    a.click();
    cv.style.filter = oldFilter;
  });

  $('exportSvg').addEventListener('click', ()=>{
    const rect = cv.getBoundingClientRect();
    const W = Math.round(rect.width), H = Math.round(rect.height);

    const N       = +ctl.cells.value;
    const S       = +ctl.sq.value;
    const Wstreet = +ctl.street.value;
    const R       = +ctl.round.value;
    const DOTS    = ctl.dots.checked;
    const DOTR    = +ctl.dotR.value;

    const darkHex = shadeFromDarkness(+ctl.dark.value);
    const sqCol   = ctl.invert.checked ? '#ffffff' : darkHex;
    const bgCol   = ctl.invert.checked ? darkHex : '#ffffff';

    const totalW = N*S + (N-1)*Wstreet;
    const totalH = totalW;
    const startX = (W - totalW)/2, startY = (H - totalH)/2;

    const parts = [];
    parts.push(`<rect x="0" y="0" width="${W}" height="${H}" fill="${bgCol}"/>`);
    for (let r=0; r<N; r++){
      for (let c=0; c<N; c++){
        const x = startX + c*(S+Wstreet);
        const y = startY + r*(S+Wstreet);
        const rx = Math.min(R, S/2);
        parts.push(`<rect x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${S}" height="${S}" rx="${rx}" ry="${rx}" fill="${sqCol}"/>`);
      }
    }
    if (DOTS){
      const dotFill = ctl.invert.checked ? darkHex : '#ffffff';
      for (let r=0; r<N-1; r++){
        for (let c=0; c<N-1; c++){
          const cx = startX + (c+1)*S + c*Wstreet + Wstreet/2;
          const cy = startY + (r+1)*S + r*Wstreet + Wstreet/2;
          parts.push(`<circle cx="${cx.toFixed(2)}" cy="${cy.toFixed(2)}" r="${DOTR}" fill="${dotFill}"/>`);
        }
      }
    }

    const svg =
`<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
  ${parts.join('\n  ')}
</svg>`;

    const blob=new Blob([svg], {type:'image/svg+xml'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='hermann-grid.svg'; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  });

  $('reset').addEventListener('click', ()=> applyPreset(paramPresets[0]));

  /* ---------- wire up controls (THIS WAS THE BUG) ---------- */
  function bindControls(){
    Object.values(ctl).forEach(input=>{
      const ev = (input.type === 'checkbox') ? 'change' : 'input';
      input.addEventListener(ev, ()=>{
        markActivePreset('');   // you’re off a preset now
        draw();                 // <- redraw with the new value
      }, {passive:true});
    });
  }

  /* ---------- boot ---------- */
  function init(){
    fitCanvas();
    window.addEventListener('resize', ()=>{fitCanvas(); draw();}, {passive:true});
    buildPresetButtons();
    bindControls();            // <- ensure controls actually drive redraws
    applyPreset(paramPresets[0]);
  }
  init();
})();
</script>
</body>
</html>