---
layout: null
permalink: /illusions/rotating-snake.html
robots: noindex
---
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rotating Snakes — mobile-first walkthrough</title>
<link rel="stylesheet" href="../assets/css/illusion-demo.css" />
<style>
  .demo-surface canvas { --demo-aspect: 1 / 1; }
</style>
</head>
<body>
<main class="illusion-page">
  <section class="hero">
    <p class="kicker">Rotating snakes</p>
    <h1>Change the number of rings and watch the pattern writhe</h1>
    <p class="lede">Each ring uses four colours in a repeating order. The right alignment of high-contrast edges makes the snakes appear to drift. Start with the ring count below, then unlock colour and layout controls.</p>
    <div class="demo-frame">
      <p class="kicker">Live canvas</p>
      <div class="demo-surface">
        <canvas id="cv" aria-label="Rotating Snakes illusion canvas"></canvas>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-rings">
    <p class="kicker">Step 1 · Core layout</p>
    <h2>Pick how many rings appear</h2>
    <p>Even a single ring can shimmer, but multiple concentric rings emphasise the apparent rotation.</p>
    <div class="controls">
      <div class="control-row">
        <label for="rings">Number of rings</label>
        <input id="rings" type="range" min="1" max="8" value="4" />
        <span id="ringsVal" class="value">4</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-layout">
    <p class="kicker">Step 2 · Layout refinements</p>
    <h2>Control ring density, thickness, and edge wobble</h2>
    <p>Fine-tune the number of tiles per ring, ring thickness, spacing, and edge curvature. Alternating directions and separators influence the strength of motion.</p>
    <div class="controls">
      <div class="control-row">
        <label for="units">Units per ring (tiles)</label>
        <input id="units" type="range" min="8" max="96" step="2" value="36" />
        <span id="unitsVal" class="value">36</span>
      </div>
      <div class="control-row">
        <label for="thick">Ring thickness (px)</label>
        <input id="thick" type="range" min="8" max="80" value="34" />
        <span id="thickVal" class="value">34</span>
      </div>
      <div class="control-row">
        <label for="gap">Gap between rings (px)</label>
        <input id="gap" type="range" min="2" max="32" value="10" />
        <span id="gapVal" class="value">10</span>
      </div>
      <div class="control-row">
        <label for="inner">Inner radius (px)</label>
        <input id="inner" type="range" min="20" max="260" value="110" />
        <span id="innerVal" class="value">110</span>
      </div>
      <div class="control-row">
        <label for="amp">Curvy edge amplitude (px)</label>
        <input id="amp" type="range" min="0" max="24" value="12" />
        <span id="ampVal" class="value">12</span>
      </div>
      <div class="control-row">
        <label for="freq">Curvy edge frequency</label>
        <input id="freq" type="range" min="1" max="10" value="4" />
        <span id="freqVal" class="value">4</span>
      </div>
      <div class="control-check">
        <input id="altDir" type="checkbox" checked />
        <label for="altDir">Alternate ring direction</label>
      </div>
      <div class="control-check">
        <input id="seps" type="checkbox" checked />
        <label for="seps">Thin separators (boost edges)</label>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-colours">
    <p class="kicker">Step 3 · Colour sequence</p>
    <h2>Set the four-step palette that drives motion cues</h2>
    <p>The order of colours matters: a sharp luminance jump followed by lighter tones makes motion pop. Reverse the sequence to flip perceived spin.</p>
    <div class="controls">
      <div class="control-row">
        <label for="c1">Step 1 (Black)</label>
        <input id="c1" type="color" value="#000000" />
        <span class="value" data-for="c1">#000000</span>
      </div>
      <div class="control-row">
        <label for="c2">Step 2 (Dark)</label>
        <input id="c2" type="color" value="#2a49d1" />
        <span class="value" data-for="c2">#2a49d1</span>
      </div>
      <div class="control-row">
        <label for="c3">Step 3 (White)</label>
        <input id="c3" type="color" value="#ffffff" />
        <span class="value" data-for="c3">#ffffff</span>
      </div>
      <div class="control-row">
        <label for="c4">Step 4 (Light)</label>
        <input id="c4" type="color" value="#9fbaff" />
        <span class="value" data-for="c4">#9fbaff</span>
      </div>
      <div class="control-check">
        <input id="rev" type="checkbox" />
        <label for="rev">Reverse order</label>
      </div>
      <p class="control-note">Order matters: <strong>Black → Dark → White → Light</strong> is the classic sequence.</p>
      <div class="control-note">Colour presets</div>
      <div id="presetRow" class="button-row presets"></div>
    </div>
  </section>

  <section class="stage" id="stage-params">
    <p class="kicker">Step 4 · Parameter presets</p>
    <h2>Snap to known-good slider combinations</h2>
    <p>These presets tweak the geometry without touching colours. Mix with the palettes above to explore variants quickly.</p>
    <div class="controls">
      <div id="paramPresetRow" class="button-row presets"></div>
    </div>
  </section>

  <section class="stage" id="stage-extras">
    <p class="kicker">Step 5 · Extras & export</p>
    <h2>Scale the pattern, add flicker, or save your design</h2>
    <p>Use the global scale and gentle flicker boost for demos, then export PNG/SVG or randomise everything for inspiration.</p>
    <div class="controls">
      <div class="control-row">
        <label for="scale">Global scale (%)</label>
        <input id="scale" type="range" min="50" max="180" value="100" />
        <span id="scaleVal" class="value">100%</span>
      </div>
      <div class="control-check">
        <input id="flick" type="checkbox" />
        <label for="flick">Subtle flicker boost (0.8 Hz)</label>
      </div>
      <div class="button-row">
        <button id="exportPng" class="btn" type="button">Export PNG</button>
        <button id="exportSvg" class="btn" type="button">Export SVG</button>
        <button id="randomise" class="btn" type="button">Randomise</button>
        <button id="reset" class="btn" type="button">Reset</button>
      </div>
    </div>
  </section>
</main>
<script>
(() => {
  const $ = id => document.getElementById(id);
  const cv = $('cv'); const ctx = cv.getContext('2d');

  const ctl = {
    rings:$('rings'), units:$('units'), thick:$('thick'), gap:$('gap'), inner:$('inner'),
    amp:$('amp'), freq:$('freq'), altDir:$('altDir'), seps:$('seps'),
    c1:$('c1'), c2:$('c2'), c3:$('c3'), c4:$('c4'), rev:$('rev'),
    scale:$('scale'), flick:$('flick')
  };
  const valSpans = {
    rings:$('ringsVal'), units:$('unitsVal'), thick:$('thickVal'), gap:$('gapVal'),
    inner:$('innerVal'), amp:$('ampVal'), freq:$('freqVal'), scale:$('scaleVal')
  };
  const colourValueSpans = {
    c1:document.querySelector('.value[data-for="c1"]'),
    c2:document.querySelector('.value[data-for="c2"]'),
    c3:document.querySelector('.value[data-for="c3"]'),
    c4:document.querySelector('.value[data-for="c4"]'),
  };

  /* ---------- canvas sizing ---------- */
  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const rect = cv.getBoundingClientRect();
    cv.width = Math.round(rect.width*dpr);
    cv.height = Math.round(rect.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  /* ---------- utils ---------- */
  function hexToRgb(hex){ const n=parseInt(hex.slice(1),16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
  function rgbToHex(o){return '#'+[o.r,o.g,o.b].map(v=>v.toString(16).padStart(2,'0')).join('');}
  function clamp(v,a=0,b=255){return Math.min(b,Math.max(a,v));}
  function relLuma(rgb){ const lin=c=>{c/=255;return c<=0.04045?c/12.92:Math.pow((c+0.055)/1.055,2.4)}; const R=lin(rgb.r),G=lin(rgb.g),B=lin(rgb.b); return 0.2126*R+0.7152*G+0.0722*B; }

  /* ---------- fixed high-contrast colour presets ---------- */
  // Each: [Black, Dark(coloured), White, Light(coloured)] — chosen so luminance order is Black < Dark < Light < White
  const colourPresets = [
    { id:'classic', name:'Classic Mono', seq:['#000000','#555555','#ffffff','#bbbbbb'] },
    { id:'royal',   name:'Royal Blue',   seq:['#000000','#2a49d1','#ffffff','#9fbaff'] },
    { id:'teal',    name:'Teal',         seq:['#000000','#0c6a6a','#ffffff','#7fd8d3'] },
    { id:'auberg',  name:'Aubergine',    seq:['#000000','#5a1f7a','#ffffff','#c7a2e8'] },
    { id:'forest',  name:'Forest',       seq:['#000000','#245d2a','#ffffff','#a8e6a2'] },
    { id:'gold',    name:'Gold',         seq:['#000000','#7a5a14','#ffffff','#f4d27a'] },
    { id:'magenta', name:'Magenta/Mint', seq:['#000000','#7a1b5a','#ffffff','#b7f7c0'] },
    { id:'slate',   name:'Slate',        seq:['#000000','#384055','#ffffff','#aab3c9'] }
  ];
  function isSeqMonotonic(seq){
    const y = seq.map(h => relLuma(hexToRgb(h)));
    return (y[0] < y[1]-0.05) && (y[1] < y[3]-0.05) && (y[3] < y[2]-0.05);
  }

  const presetRow = $('presetRow');
  let activeColourPreset = '';

  function applyColourSeq(seq){
    // Safety: keep only sequences with the right luminance ordering
    const s = isSeqMonotonic(seq) ? seq : colourPresets[0].seq;
    ctl.c1.value = s[0]; ctl.c2.value = s[1]; ctl.c3.value = s[2]; ctl.c4.value = s[3];
    updateColourLabels();
    draw();
  }
  function setActiveColourPreset(id){
    activeColourPreset = id;
    [...presetRow.querySelectorAll('button')].forEach(b=>{
      const on = b.dataset.pid === id;
      b.classList.toggle('active', on);
      b.setAttribute('aria-pressed', on ? 'true' : 'false');
    });
  }
  function buildColourPresetButtons(){
    colourPresets.forEach(p=>{
      const b = document.createElement('button');
      b.className = 'btn';
      b.textContent = p.name;
      b.dataset.pid = p.id;
      b.type = 'button';
      b.setAttribute('aria-pressed','false');
      b.addEventListener('click', ()=>{
        applyColourSeq(p.seq);
        setActiveColourPreset(p.id);
      });
      presetRow.appendChild(b);
    });
    // Default to Royal Blue (clear visual change from grey)
    applyColourSeq(colourPresets[1].seq);
    setActiveColourPreset('royal');
  }

  // Manual colour tweaks clear preset highlight (you’re off-preset now)
  [ctl.c1, ctl.c2, ctl.c3, ctl.c4].forEach(inp=>{
    inp.addEventListener('input', ()=>{ updateColourLabels(); setActiveColourPreset(''); draw(); }, {passive:true});
  });
  function updateColourLabels(){
    document.querySelector('.value[data-for="c1"]').textContent = ctl.c1.value.toLowerCase();
    document.querySelector('.value[data-for="c2"]').textContent = ctl.c2.value.toLowerCase();
    document.querySelector('.value[data-for="c3"]').textContent = ctl.c3.value.toLowerCase();
    document.querySelector('.value[data-for="c4"]').textContent = ctl.c4.value.toLowerCase();
  }

  function getSeq(){
    const seq = [ctl.c1.value, ctl.c2.value, ctl.c3.value, ctl.c4.value];
    return ctl.rev.checked ? seq.slice().reverse() : seq;
  }

  /* ---------- parameter presets ---------- */
  const paramPresetRow = $('paramPresetRow');
  const paramPresets = [
    { id:'classicStrong', name:'Classic (strong)', rings:4, units:36, thick:34, gap:10, inner:110, amp:12, freq:4, altDir:true, seps:true },
    { id:'denseMosaic',   name:'Dense mosaic',    rings:6, units:64, thick:22, gap:6,  inner:90,  amp:10, freq:6, altDir:true, seps:true },
    { id:'boldWide',      name:'Bold wide',       rings:3, units:28, thick:48, gap:14, inner:130, amp:12, freq:3, altDir:true, seps:true },
    { id:'fineSubtle',    name:'Fine subtle',     rings:5, units:80, thick:16, gap:6,  inner:100, amp:8,  freq:5, altDir:true, seps:true },
    { id:'compactPunchy', name:'Compact punchy',  rings:5, units:40, thick:26, gap:8,  inner:70,  amp:12, freq:5, altDir:true, seps:true }
  ];
  function applyParamPreset(p){
    ctl.rings.value=p.rings; ctl.units.value=p.units; ctl.thick.value=p.thick; ctl.gap.value=p.gap;
    ctl.inner.value=p.inner; ctl.amp.value=p.amp; ctl.freq.value=p.freq;
    ctl.altDir.checked=!!p.altDir; ctl.seps.checked=!!p.seps;
    updateLabels(); draw();
  }
  function buildParamPresetButtons(){
    paramPresets.forEach(p=>{
      const b = document.createElement('button');
      b.className = 'btn';
      b.textContent = p.name;
      b.dataset.pid = p.id;
      b.type = 'button';
      b.addEventListener('click', ()=> applyParamPreset(p));
      paramPresetRow.appendChild(b);
    });
    applyParamPreset(paramPresets[0]);
  }

  // Labels
  function updateLabels(){
    valSpans.rings.textContent = ctl.rings.value;
    valSpans.units.textContent = ctl.units.value;
    valSpans.thick.textContent = ctl.thick.value;
    valSpans.gap.textContent   = ctl.gap.value;
    valSpans.inner.textContent = ctl.inner.value;
    valSpans.amp.textContent   = ctl.amp.value;
    valSpans.freq.textContent  = ctl.freq.value;
    valSpans.scale.textContent = ctl.scale.value + '%';
  }

  /* ---------- drawing ---------- */
  function draw(){
    updateLabels();
    const W=cv.width, H=cv.height;
    ctx.clearRect(0,0,W,H);
    ctx.save(); ctx.translate(W/2,H/2);
    const scale = +ctl.scale.value/100; ctx.scale(scale,scale);

    const rings=+ctl.rings.value, units=+ctl.units.value, thick=+ctl.thick.value;
    const gap=+ctl.gap.value, inner=+ctl.inner.value, amp=+ctl.amp.value, freq=+ctl.freq.value;
    const colours = getSeq();
    const unitA = (Math.PI*2)/units, stepA = unitA/4;
    const drawSep = ctl.seps.checked;

    for (let r=0;r<rings;r++){
      const rIn = inner + r*(thick+gap), rOut = rIn+thick;
      const phase = ctl.altDir.checked && (r%2===1) ? stepA*2 : 0;
      for (let u=0;u<units;u++){
        const base = u*unitA + phase;
        for (let s=0;s<4;s++){
          const a1 = base + s*stepA, a2 = a1 + stepA;
          curvedPatch(ctx, rIn, rOut, a1, a2, amp, freq, colours[s]);
          if (drawSep){ ctx.save(); ctx.strokeStyle='rgba(0,0,0,.75)'; ctx.lineWidth=0.6; arcEdge(ctx,rIn,rOut,a2,amp,freq); ctx.restore(); }
        }
      }
    }
    ctx.restore();
  }

  function arcEdge(ctx,rIn,rOut,theta,amp,freq){
    const steps=18;
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const k=i/steps;
      const rr = rIn + (rOut-rIn)*k + amp*Math.sin(freq*theta + (k*Math.PI*2/3));
      const x=rr*Math.cos(theta), y=rr*Math.sin(theta);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  function curvedPatch(ctx,rIn,rOut,a1,a2,amp,freq,fill){
    const steps=Math.max(8, Math.floor((a2-a1)*64));
    const phase= Math.PI/2;
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const t=a1+(a2-a1)*(i/steps);
      const ri=rIn + amp*Math.sin(freq*t);
      const x=ri*Math.cos(t), y=ri*Math.sin(t);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    for(let i=steps;i>=0;i--){
      const t=a1+(a2-a1)*(i/steps);
      const ro=rOut + amp*Math.sin(freq*t + phase);
      const x=ro*Math.cos(t), y=ro*Math.sin(t);
      ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fillStyle=fill; ctx.fill();
  }

  /* ---------- Export PNG ---------- */
  $('exportPng').addEventListener('click', ()=>{
    const a=document.createElement('a');
    a.download='rotating-snakes.png';
    a.href=cv.toDataURL('image/png');
    a.click();
  });

  /* ---------- Export SVG ---------- */
  $('exportSvg').addEventListener('click', ()=>{
    const rect = cv.getBoundingClientRect();
    const W = Math.round(rect.width), H = Math.round(rect.height);
    const scale = +ctl.scale.value/100;

    const rings=+ctl.rings.value, units=+ctl.units.value, thick=+ctl.thick.value;
    const gap=+ctl.gap.value, inner=+ctl.inner.value, amp=+ctl.amp.value, freq=+ctl.freq.value;
    const colours = getSeq();
    const unitA=(Math.PI*2)/units, stepA=unitA/4;
    const drawSep = ctl.seps.checked;

    function pathForPatch(rIn,rOut,a1,a2,amp,freq,phase){
      const steps=Math.max(8, Math.floor((a2-a1)*64));
      const pts=[];
      for(let i=0;i<=steps;i++){
        const t=a1+(a2-a1)*(i/steps);
        const ri=rIn + amp*Math.sin(freq*t);
        pts.push([ri*Math.cos(t), ri*Math.sin(t)]);
      }
      for(let i=steps;i>=0;i--){
        const t=a1+(a2-a1)*(i/steps);
        const ro=rOut + amp*Math.sin(freq*t + phase);
        pts.push([ro*Math.cos(t), ro*Math.sin(t)]);
      }
      let d='M '+pts[0][0].toFixed(2)+' '+pts[0][1].toFixed(2);
      for(let i=1;i<pts.length;i++) d+=' L '+pts[i][0].toFixed(2)+' '+pts[i][1].toFixed(2);
      d+=' Z'; return d;
    }
    function sepEdge(rIn,rOut,theta,amp,freq){
      const steps=18, pts=[];
      for(let i=0;i<=steps;i++){
        const k=i/steps;
        const rr = rIn + (rOut-rIn)*k + amp*Math.sin(freq*theta + (k*Math.PI*2/3));
        pts.push([rr*Math.cos(theta), rr*Math.sin(theta)]);
      }
      let d='M '+pts[0][0].toFixed(2)+' '+pts[0][1].toFixed(2);
      for(let i=1;i<pts.length;i++) d+=' L '+pts[i][0].toFixed(2)+' '+pts[i][1].toFixed(2);
      return d;
    }

    const paths=[];
    for(let r=0;r<rings;r++){
      const rIn = inner + r*(thick+gap), rOut=rIn+thick;
      const phase = ctl.altDir.checked && (r%2===1) ? stepA*2 : 0;
      for(let u=0;u<units;u++){
        const base = u*unitA + phase;
        for(let s=0;s<4;s++){
          const a1=base+s*stepA, a2=a1+stepA;
          const d = pathForPatch(rIn,rOut,a1,a2,amp,freq,Math.PI/2);
          const col = colours[s];
          paths.push(`<path d="${d}" fill="${col}" />`);
          if(drawSep){
            const d2 = sepEdge(rIn,rOut,a2,amp,freq);
            paths.push(`<path d="${d2}" fill="none" stroke="rgba(0,0,0,0.75)" stroke-width="0.6" />`);
          }
        }
      }
    }

    const svg =
`<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
  <rect width="100%" height="100%" fill="#ffffff"/>
  <g transform="translate(${W/2},${H/2}) scale(${scale})">
    ${paths.join('\n    ')}
  </g>
</svg>`;

    const blob=new Blob([svg], {type:'image/svg+xml'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='rotating-snakes.svg'; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  });

  /* ---------- random & reset ---------- */
  $('randomise').addEventListener('click', ()=>{
    // random colour + parameter preset
    const cp = colourPresets[Math.floor(Math.random()*colourPresets.length)];
    applyColourSeq(cp.seq); setActiveColourPreset(cp.id);
    const pp = ['classicStrong','denseMosaic','boldWide','fineSubtle','compactPunchy'];
    const chosen = pp[Math.floor(Math.random()*pp.length)];
    applyParamPreset(paramPresets.find(p=>p.id===chosen));
  });

  $('reset').addEventListener('click', ()=>{
    applyColourSeq(colourPresets[1].seq); setActiveColourPreset('royal'); // visible default
    applyParamPreset(paramPresets[0]);
    ctl.rev.checked=false; ctl.scale.value=100; ctl.flick.checked=false;
    updateLabels(); draw();
  });

  /* ---------- inputs & animation ---------- */
  function bindInputs(){
    document.querySelectorAll('input').forEach(inp=>{
      const ev = (inp.type==='range'||inp.type==='color'||inp.type==='checkbox') ? 'input' : 'change';
      inp.addEventListener(ev, ()=>{
        if (inp === ctl.scale) valSpans.scale.textContent = ctl.scale.value + '%';
        draw();
      }, {passive:true});
    });
    window.addEventListener('resize', ()=>{fitCanvas(); draw();}, {passive:true});
  }

  let tFlick=0;
  function animate(){
    if (ctl.flick.checked){
      tFlick += 0.016;
      const k = 0.08 * Math.sin(2*Math.PI*0.8*tFlick);
      const base=[ctl.c1.value, ctl.c2.value, ctl.c3.value, ctl.c4.value].map(hexToRgb);
      const wobble=[
        base[0],
        {r:clamp(base[1].r*(1+k)), g:clamp(base[1].g*(1+k)), b:clamp(base[1].b*(1+k))},
        {r:clamp(base[2].r*(1-k)), g:clamp(base[2].g*(1-k)), b:clamp(base[2].b*(1-k))},
        base[3]
      ].map(rgbToHex);
      tempDraw(wobble);
    } else {
      draw();
    }
    requestAnimationFrame(animate);
  }
  function tempDraw(seq){
    const W=cv.width, H=cv.height;
    ctx.clearRect(0,0,W,H);
    ctx.save(); ctx.translate(W/2,H/2);
    const scale = +ctl.scale.value/100; ctx.scale(scale,scale);
    const rings=+ctl.rings.value, units=+ctl.units.value, thick=+ctl.thick.value;
    const gap=+ctl.gap.value, inner=+ctl.inner.value, amp=+ctl.amp.value, freq=+ctl.freq.value;
    const unitA=(Math.PI*2)/units, stepA=unitA/4, drawSep=ctl.seps.checked;
    for(let r=0;r<rings;r++){
      const rIn=inner+r*(thick+gap), rOut=rIn+thick, phase = ctl.altDir.checked && (r%2===1) ? stepA*2 : 0;
      for(let u=0;u<units;u++){
        const base=u*unitA + phase;
        for(let s=0;s<4;s++){
          const a1=base+s*stepA, a2=a1+stepA;
          const idx = ctl.rev.checked ? (3-s) : s;
          curvedPatch(ctx,rIn,rOut,a1,a2,amp,freq,seq[idx]);
          if (drawSep){ ctx.save(); ctx.strokeStyle='rgba(0,0,0,.75)'; ctx.lineWidth=0.6; arcEdge(ctx,rIn,rOut,a2,amp,freq); ctx.restore(); }
        }
      }
    }
    ctx.restore();
  }

  /* ---------- boot ---------- */
  function init(){
    fitCanvas(); updateLabels(); updateColourLabels(); bindInputs();
    buildColourPresetButtons();
    buildParamPresetButtons();
    draw(); requestAnimationFrame(animate);
  }
  init();
})();
</script>
</body>
</html>