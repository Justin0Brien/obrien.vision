---
layout: null
permalink: /illusions/rotating-snake.html
robots: noindex
---
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rotating Snakes — Working Colour Presets + SVG export</title>
<style>
  :root{
    --bg:#f5f5f7; --ink:#111; --panel:#fff; --accent:#2563eb; --accent-strong:#1d4ed8;
    --soft:#e5e7eb; --soft2:#d1d5db;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{display:grid;grid-template-columns: 560px 1fr; gap:16px; padding:16px; height:100%; box-sizing:border-box}
  .controls{background:var(--panel); border-radius:12px; padding:16px; box-shadow:0 1px 3px rgba(0,0,0,.08); overflow:auto}
  fieldset{border:1px solid var(--soft); border-radius:10px; margin:0 0 14px; padding:10px 12px}
  legend{padding:0 6px; font-weight:650; color:#374151}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .hint{font-size:13px;color:#4b5563}
  canvas{width:100%;height:100%;display:block;background:#fff;border-radius:12px;box-shadow:0 1px 3px rgba(0,0,0,.08)}
  .ctl{ display:grid; grid-template-columns: 1fr 280px 64px; gap:10px; align-items:center; margin:8px 0; }
  .ctl input[type="range"]{width:100%}
  .value{justify-self:end; min-width:64px; text-align:right; color:#111; font-variant-numeric: tabular-nums}
  input[type="color"]{width:64px;height:28px;padding:0;border:none;background:none}
  .btn{ background:var(--soft); color:#111; border:none; border-radius:10px; padding:8px 12px; cursor:pointer; }
  .btn:hover{background:var(--soft2)}
  .presets .btn.active{background:var(--accent); color:#fff; box-shadow: inset 0 0 0 2px rgba(255,255,255,.6)}
  .section-label{font-weight:600; margin:6px 0 4px}
</style>
</head>
<body>
<div class="wrap">
  <div class="controls">
    <fieldset>
      <legend>Layout</legend>
      <div class="ctl"><span>Number of rings</span><input id="rings" type="range" min="1" max="8" value="4"><span id="ringsVal" class="value">4</span></div>
      <div class="ctl"><span>Units per ring (tiles)</span><input id="units" type="range" min="8" max="96" step="2" value="36"><span id="unitsVal" class="value">36</span></div>
      <div class="ctl"><span>Ring thickness (px)</span><input id="thick" type="range" min="8" max="80" value="34"><span id="thickVal" class="value">34</span></div>
      <div class="ctl"><span>Gap between rings (px)</span><input id="gap" type="range" min="2" max="32" value="10"><span id="gapVal" class="value">10</span></div>
      <div class="ctl"><span>Inner radius (px)</span><input id="inner" type="range" min="20" max="260" value="110"><span id="innerVal" class="value">110</span></div>
      <div class="ctl"><span>Curvy edge amplitude (px)</span><input id="amp" type="range" min="0" max="24" value="12"><span id="ampVal" class="value">12</span></div>
      <div class="ctl"><span>Curvy edge frequency</span><input id="freq" type="range" min="1" max="10" value="4"><span id="freqVal" class="value">4</span></div>
      <div class="ctl"><span>Alternate ring direction</span><input id="altDir" type="checkbox" checked><span class="value" aria-hidden="true"></span></div>
      <div class="ctl"><span>Thin separators (boost edges)</span><input id="seps" type="checkbox" checked><span class="value" aria-hidden="true"></span></div>
    </fieldset>

    <fieldset>
      <legend>Colours</legend>
      <div class="hint">Order matters (tangentially): <strong>Black → Dark → White → Light</strong>. Reversing flips perceived rotation.</div>
      <div class="ctl"><span>Step 1 (Black)</span><input id="c1" type="color" value="#000000"><span class="value" data-for="c1">#000000</span></div>
      <div class="ctl"><span>Step 2 (Dark)</span><input id="c2" type="color" value="#2a49d1"><span class="value" data-for="c2">#2a49d1</span></div>
      <div class="ctl"><span>Step 3 (White)</span><input id="c3" type="color" value="#ffffff"><span class="value" data-for="c3">#ffffff</span></div>
      <div class="ctl"><span>Step 4 (Light)</span><input id="c4" type="color" value="#9fbaff"><span class="value" data-for="c4">#9fbaff</span></div>
      <div class="ctl"><span>Reverse order</span><input id="rev" type="checkbox"><span class="value" aria-hidden="true"></span></div>

      <div class="section-label">Colour presets</div>
      <div id="presetRow" class="row presets"></div>
      <div class="hint">Presets use fixed, high-contrast palettes to keep the illusion strong.</div>
    </fieldset>

    <fieldset>
      <legend>Parameter presets</legend>
      <div id="paramPresetRow" class="row presets"></div>
      <p class="hint">Snap to known-good slider settings.</p>
    </fieldset>

    <fieldset>
      <legend>Extras</legend>
      <div class="ctl"><span>Global scale (%)</span><input id="scale" type="range" min="50" max="180" value="100"><span id="scaleVal" class="value">100%</span></div>
      <div class="ctl"><span>Subtle flicker boost (0.8 Hz)</span><input id="flick" type="checkbox"><span class="value" aria-hidden="true"></span></div>
      <div class="row">
        <button id="exportPng" class="btn">Export PNG</button>
        <button id="exportSvg" class="btn">Export SVG</button>
        <button id="randomise" class="btn">Randomise</button>
        <button id="reset" class="btn">Reset</button>
      </div>
    </fieldset>
  </div>

  <canvas id="cv" aria-label="Rotating Snakes illusion canvas"></canvas>
</div>

<script>
(() => {
  const $ = id => document.getElementById(id);
  const cv = $('cv'); const ctx = cv.getContext('2d');

  const ctl = {
    rings:$('rings'), units:$('units'), thick:$('thick'), gap:$('gap'), inner:$('inner'),
    amp:$('amp'), freq:$('freq'), altDir:$('altDir'), seps:$('seps'),
    c1:$('c1'), c2:$('c2'), c3:$('c3'), c4:$('c4'), rev:$('rev'),
    scale:$('scale'), flick:$('flick')
  };
  const valSpans = {
    rings:$('ringsVal'), units:$('unitsVal'), thick:$('thickVal'), gap:$('gapVal'),
    inner:$('innerVal'), amp:$('ampVal'), freq:$('freqVal'), scale:$('scaleVal')
  };
  const colourValueSpans = {
    c1:document.querySelector('.value[data-for="c1"]'),
    c2:document.querySelector('.value[data-for="c2"]'),
    c3:document.querySelector('.value[data-for="c3"]'),
    c4:document.querySelector('.value[data-for="c4"]'),
  };

  /* ---------- canvas sizing ---------- */
  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const rect = cv.getBoundingClientRect();
    cv.width = Math.round(rect.width*dpr);
    cv.height = Math.round(rect.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  /* ---------- utils ---------- */
  function hexToRgb(hex){ const n=parseInt(hex.slice(1),16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
  function rgbToHex(o){return '#'+[o.r,o.g,o.b].map(v=>v.toString(16).padStart(2,'0')).join('');}
  function clamp(v,a=0,b=255){return Math.min(b,Math.max(a,v));}
  function relLuma(rgb){ const lin=c=>{c/=255;return c<=0.04045?c/12.92:Math.pow((c+0.055)/1.055,2.4)}; const R=lin(rgb.r),G=lin(rgb.g),B=lin(rgb.b); return 0.2126*R+0.7152*G+0.0722*B; }

  /* ---------- fixed high-contrast colour presets ---------- */
  // Each: [Black, Dark(coloured), White, Light(coloured)] — chosen so luminance order is Black < Dark < Light < White
  const colourPresets = [
    { id:'classic', name:'Classic Mono', seq:['#000000','#555555','#ffffff','#bbbbbb'] },
    { id:'royal',   name:'Royal Blue',   seq:['#000000','#2a49d1','#ffffff','#9fbaff'] },
    { id:'teal',    name:'Teal',         seq:['#000000','#0c6a6a','#ffffff','#7fd8d3'] },
    { id:'auberg',  name:'Aubergine',    seq:['#000000','#5a1f7a','#ffffff','#c7a2e8'] },
    { id:'forest',  name:'Forest',       seq:['#000000','#245d2a','#ffffff','#a8e6a2'] },
    { id:'gold',    name:'Gold',         seq:['#000000','#7a5a14','#ffffff','#f4d27a'] },
    { id:'magenta', name:'Magenta/Mint', seq:['#000000','#7a1b5a','#ffffff','#b7f7c0'] },
    { id:'slate',   name:'Slate',        seq:['#000000','#384055','#ffffff','#aab3c9'] }
  ];
  function isSeqMonotonic(seq){
    const y = seq.map(h => relLuma(hexToRgb(h)));
    return (y[0] < y[1]-0.05) && (y[1] < y[3]-0.05) && (y[3] < y[2]-0.05);
  }

  const presetRow = $('presetRow');
  let activeColourPreset = '';

  function applyColourSeq(seq){
    // Safety: keep only sequences with the right luminance ordering
    const s = isSeqMonotonic(seq) ? seq : colourPresets[0].seq;
    ctl.c1.value = s[0]; ctl.c2.value = s[1]; ctl.c3.value = s[2]; ctl.c4.value = s[3];
    updateColourLabels();
    draw();
  }
  function setActiveColourPreset(id){
    activeColourPreset = id;
    [...presetRow.querySelectorAll('button')].forEach(b=>{
      const on = b.dataset.pid === id;
      b.classList.toggle('active', on);
      b.setAttribute('aria-pressed', on ? 'true' : 'false');
    });
  }
  function buildColourPresetButtons(){
    colourPresets.forEach(p=>{
      const b = document.createElement('button');
      b.className = 'btn';
      b.textContent = p.name;
      b.dataset.pid = p.id;
      b.type = 'button';
      b.setAttribute('aria-pressed','false');
      b.addEventListener('click', ()=>{
        applyColourSeq(p.seq);
        setActiveColourPreset(p.id);
      });
      presetRow.appendChild(b);
    });
    // Default to Royal Blue (clear visual change from grey)
    applyColourSeq(colourPresets[1].seq);
    setActiveColourPreset('royal');
  }

  // Manual colour tweaks clear preset highlight (you’re off-preset now)
  [ctl.c1, ctl.c2, ctl.c3, ctl.c4].forEach(inp=>{
    inp.addEventListener('input', ()=>{ updateColourLabels(); setActiveColourPreset(''); draw(); }, {passive:true});
  });
  function updateColourLabels(){
    document.querySelector('.value[data-for="c1"]').textContent = ctl.c1.value.toLowerCase();
    document.querySelector('.value[data-for="c2"]').textContent = ctl.c2.value.toLowerCase();
    document.querySelector('.value[data-for="c3"]').textContent = ctl.c3.value.toLowerCase();
    document.querySelector('.value[data-for="c4"]').textContent = ctl.c4.value.toLowerCase();
  }

  function getSeq(){
    const seq = [ctl.c1.value, ctl.c2.value, ctl.c3.value, ctl.c4.value];
    return ctl.rev.checked ? seq.slice().reverse() : seq;
  }

  /* ---------- parameter presets ---------- */
  const paramPresetRow = $('paramPresetRow');
  const paramPresets = [
    { id:'classicStrong', name:'Classic (strong)', rings:4, units:36, thick:34, gap:10, inner:110, amp:12, freq:4, altDir:true, seps:true },
    { id:'denseMosaic',   name:'Dense mosaic',    rings:6, units:64, thick:22, gap:6,  inner:90,  amp:10, freq:6, altDir:true, seps:true },
    { id:'boldWide',      name:'Bold wide',       rings:3, units:28, thick:48, gap:14, inner:130, amp:12, freq:3, altDir:true, seps:true },
    { id:'fineSubtle',    name:'Fine subtle',     rings:5, units:80, thick:16, gap:6,  inner:100, amp:8,  freq:5, altDir:true, seps:true },
    { id:'compactPunchy', name:'Compact punchy',  rings:5, units:40, thick:26, gap:8,  inner:70,  amp:12, freq:5, altDir:true, seps:true }
  ];
  function applyParamPreset(p){
    ctl.rings.value=p.rings; ctl.units.value=p.units; ctl.thick.value=p.thick; ctl.gap.value=p.gap;
    ctl.inner.value=p.inner; ctl.amp.value=p.amp; ctl.freq.value=p.freq;
    ctl.altDir.checked=!!p.altDir; ctl.seps.checked=!!p.seps;
    updateLabels(); draw();
  }
  function buildParamPresetButtons(){
    paramPresets.forEach(p=>{
      const b = document.createElement('button');
      b.className = 'btn';
      b.textContent = p.name;
      b.dataset.pid = p.id;
      b.type = 'button';
      b.addEventListener('click', ()=> applyParamPreset(p));
      paramPresetRow.appendChild(b);
    });
    applyParamPreset(paramPresets[0]);
  }

  // Labels
  function updateLabels(){
    valSpans.rings.textContent = ctl.rings.value;
    valSpans.units.textContent = ctl.units.value;
    valSpans.thick.textContent = ctl.thick.value;
    valSpans.gap.textContent   = ctl.gap.value;
    valSpans.inner.textContent = ctl.inner.value;
    valSpans.amp.textContent   = ctl.amp.value;
    valSpans.freq.textContent  = ctl.freq.value;
    valSpans.scale.textContent = ctl.scale.value + '%';
  }

  /* ---------- drawing ---------- */
  function draw(){
    updateLabels();
    const W=cv.width, H=cv.height;
    ctx.clearRect(0,0,W,H);
    ctx.save(); ctx.translate(W/2,H/2);
    const scale = +ctl.scale.value/100; ctx.scale(scale,scale);

    const rings=+ctl.rings.value, units=+ctl.units.value, thick=+ctl.thick.value;
    const gap=+ctl.gap.value, inner=+ctl.inner.value, amp=+ctl.amp.value, freq=+ctl.freq.value;
    const colours = getSeq();
    const unitA = (Math.PI*2)/units, stepA = unitA/4;
    const drawSep = ctl.seps.checked;

    for (let r=0;r<rings;r++){
      const rIn = inner + r*(thick+gap), rOut = rIn+thick;
      const phase = ctl.altDir.checked && (r%2===1) ? stepA*2 : 0;
      for (let u=0;u<units;u++){
        const base = u*unitA + phase;
        for (let s=0;s<4;s++){
          const a1 = base + s*stepA, a2 = a1 + stepA;
          curvedPatch(ctx, rIn, rOut, a1, a2, amp, freq, colours[s]);
          if (drawSep){ ctx.save(); ctx.strokeStyle='rgba(0,0,0,.75)'; ctx.lineWidth=0.6; arcEdge(ctx,rIn,rOut,a2,amp,freq); ctx.restore(); }
        }
      }
    }
    ctx.restore();
  }

  function arcEdge(ctx,rIn,rOut,theta,amp,freq){
    const steps=18;
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const k=i/steps;
      const rr = rIn + (rOut-rIn)*k + amp*Math.sin(freq*theta + (k*Math.PI*2/3));
      const x=rr*Math.cos(theta), y=rr*Math.sin(theta);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  function curvedPatch(ctx,rIn,rOut,a1,a2,amp,freq,fill){
    const steps=Math.max(8, Math.floor((a2-a1)*64));
    const phase= Math.PI/2;
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const t=a1+(a2-a1)*(i/steps);
      const ri=rIn + amp*Math.sin(freq*t);
      const x=ri*Math.cos(t), y=ri*Math.sin(t);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    for(let i=steps;i>=0;i--){
      const t=a1+(a2-a1)*(i/steps);
      const ro=rOut + amp*Math.sin(freq*t + phase);
      const x=ro*Math.cos(t), y=ro*Math.sin(t);
      ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fillStyle=fill; ctx.fill();
  }

  /* ---------- Export PNG ---------- */
  $('exportPng').addEventListener('click', ()=>{
    const a=document.createElement('a');
    a.download='rotating-snakes.png';
    a.href=cv.toDataURL('image/png');
    a.click();
  });

  /* ---------- Export SVG ---------- */
  $('exportSvg').addEventListener('click', ()=>{
    const rect = cv.getBoundingClientRect();
    const W = Math.round(rect.width), H = Math.round(rect.height);
    const scale = +ctl.scale.value/100;

    const rings=+ctl.rings.value, units=+ctl.units.value, thick=+ctl.thick.value;
    const gap=+ctl.gap.value, inner=+ctl.inner.value, amp=+ctl.amp.value, freq=+ctl.freq.value;
    const colours = getSeq();
    const unitA=(Math.PI*2)/units, stepA=unitA/4;
    const drawSep = ctl.seps.checked;

    function pathForPatch(rIn,rOut,a1,a2,amp,freq,phase){
      const steps=Math.max(8, Math.floor((a2-a1)*64));
      const pts=[];
      for(let i=0;i<=steps;i++){
        const t=a1+(a2-a1)*(i/steps);
        const ri=rIn + amp*Math.sin(freq*t);
        pts.push([ri*Math.cos(t), ri*Math.sin(t)]);
      }
      for(let i=steps;i>=0;i--){
        const t=a1+(a2-a1)*(i/steps);
        const ro=rOut + amp*Math.sin(freq*t + phase);
        pts.push([ro*Math.cos(t), ro*Math.sin(t)]);
      }
      let d='M '+pts[0][0].toFixed(2)+' '+pts[0][1].toFixed(2);
      for(let i=1;i<pts.length;i++) d+=' L '+pts[i][0].toFixed(2)+' '+pts[i][1].toFixed(2);
      d+=' Z'; return d;
    }
    function sepEdge(rIn,rOut,theta,amp,freq){
      const steps=18, pts=[];
      for(let i=0;i<=steps;i++){
        const k=i/steps;
        const rr = rIn + (rOut-rIn)*k + amp*Math.sin(freq*theta + (k*Math.PI*2/3));
        pts.push([rr*Math.cos(theta), rr*Math.sin(theta)]);
      }
      let d='M '+pts[0][0].toFixed(2)+' '+pts[0][1].toFixed(2);
      for(let i=1;i<pts.length;i++) d+=' L '+pts[i][0].toFixed(2)+' '+pts[i][1].toFixed(2);
      return d;
    }

    const paths=[];
    for(let r=0;r<rings;r++){
      const rIn = inner + r*(thick+gap), rOut=rIn+thick;
      const phase = ctl.altDir.checked && (r%2===1) ? stepA*2 : 0;
      for(let u=0;u<units;u++){
        const base = u*unitA + phase;
        for(let s=0;s<4;s++){
          const a1=base+s*stepA, a2=a1+stepA;
          const d = pathForPatch(rIn,rOut,a1,a2,amp,freq,Math.PI/2);
          const col = colours[s];
          paths.push(`<path d="${d}" fill="${col}" />`);
          if(drawSep){
            const d2 = sepEdge(rIn,rOut,a2,amp,freq);
            paths.push(`<path d="${d2}" fill="none" stroke="rgba(0,0,0,0.75)" stroke-width="0.6" />`);
          }
        }
      }
    }

    const svg =
`<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
  <rect width="100%" height="100%" fill="#ffffff"/>
  <g transform="translate(${W/2},${H/2}) scale(${scale})">
    ${paths.join('\n    ')}
  </g>
</svg>`;

    const blob=new Blob([svg], {type:'image/svg+xml'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='rotating-snakes.svg'; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  });

  /* ---------- random & reset ---------- */
  $('randomise').addEventListener('click', ()=>{
    // random colour + parameter preset
    const cp = colourPresets[Math.floor(Math.random()*colourPresets.length)];
    applyColourSeq(cp.seq); setActiveColourPreset(cp.id);
    const pp = ['classicStrong','denseMosaic','boldWide','fineSubtle','compactPunchy'];
    const chosen = pp[Math.floor(Math.random()*pp.length)];
    applyParamPreset(paramPresets.find(p=>p.id===chosen));
  });

  $('reset').addEventListener('click', ()=>{
    applyColourSeq(colourPresets[1].seq); setActiveColourPreset('royal'); // visible default
    applyParamPreset(paramPresets[0]);
    ctl.rev.checked=false; ctl.scale.value=100; ctl.flick.checked=false;
    updateLabels(); draw();
  });

  /* ---------- inputs & animation ---------- */
  function bindInputs(){
    document.querySelectorAll('input').forEach(inp=>{
      const ev = (inp.type==='range'||inp.type==='color'||inp.type==='checkbox') ? 'input' : 'change';
      inp.addEventListener(ev, ()=>{
        if (inp === ctl.scale) valSpans.scale.textContent = ctl.scale.value + '%';
        draw();
      }, {passive:true});
    });
    window.addEventListener('resize', ()=>{fitCanvas(); draw();}, {passive:true});
  }

  let tFlick=0;
  function animate(){
    if (ctl.flick.checked){
      tFlick += 0.016;
      const k = 0.08 * Math.sin(2*Math.PI*0.8*tFlick);
      const base=[ctl.c1.value, ctl.c2.value, ctl.c3.value, ctl.c4.value].map(hexToRgb);
      const wobble=[
        base[0],
        {r:clamp(base[1].r*(1+k)), g:clamp(base[1].g*(1+k)), b:clamp(base[1].b*(1+k))},
        {r:clamp(base[2].r*(1-k)), g:clamp(base[2].g*(1-k)), b:clamp(base[2].b*(1-k))},
        base[3]
      ].map(rgbToHex);
      tempDraw(wobble);
    } else {
      draw();
    }
    requestAnimationFrame(animate);
  }
  function tempDraw(seq){
    const W=cv.width, H=cv.height;
    ctx.clearRect(0,0,W,H);
    ctx.save(); ctx.translate(W/2,H/2);
    const scale = +ctl.scale.value/100; ctx.scale(scale,scale);
    const rings=+ctl.rings.value, units=+ctl.units.value, thick=+ctl.thick.value;
    const gap=+ctl.gap.value, inner=+ctl.inner.value, amp=+ctl.amp.value, freq=+ctl.freq.value;
    const unitA=(Math.PI*2)/units, stepA=unitA/4, drawSep=ctl.seps.checked;
    for(let r=0;r<rings;r++){
      const rIn=inner+r*(thick+gap), rOut=rIn+thick, phase = ctl.altDir.checked && (r%2===1) ? stepA*2 : 0;
      for(let u=0;u<units;u++){
        const base=u*unitA + phase;
        for(let s=0;s<4;s++){
          const a1=base+s*stepA, a2=a1+stepA;
          const idx = ctl.rev.checked ? (3-s) : s;
          curvedPatch(ctx,rIn,rOut,a1,a2,amp,freq,seq[idx]);
          if (drawSep){ ctx.save(); ctx.strokeStyle='rgba(0,0,0,.75)'; ctx.lineWidth=0.6; arcEdge(ctx,rIn,rOut,a2,amp,freq); ctx.restore(); }
        }
      }
    }
    ctx.restore();
  }

  /* ---------- boot ---------- */
  function init(){
    fitCanvas(); updateLabels(); updateColourLabels(); bindInputs();
    buildColourPresetButtons();
    buildParamPresetButtons();
    draw(); requestAnimationFrame(animate);
  }
  init();
})();
</script>
</body>
</html>