<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Café Wall Illusion — interactive, mobile-first walkthrough</title>
<link rel="stylesheet" href="../assets/css/illusion-demo.css" />
<style>
  .demo-surface canvas { --demo-aspect: 3 / 2; }
  .control-note { font-size: 13px; color: #6b7280; margin: -6px 0 0; }
</style>
</head>
<body>
<main class="illusion-page">
  <section class="hero">
    <p class="kicker">Café Wall illusion</p>
    <h1>Watch straight mortar lines lean as you change the offset</h1>
    <p class="lede">The café wall illusion comes from alternating rows of tiles that are slightly shifted. Start with the canvas, then scroll to uncover how each ingredient strengthens or weakens the effect.</p>
    <div class="demo-frame">
      <p class="kicker">Live canvas</p>
      <div class="demo-surface">
        <canvas id="cv" aria-label="Café Wall illusion canvas"></canvas>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-offset">
    <p class="kicker">Step 1 · Row offset</p>
    <h2>Offsetting alternating rows makes the mortar look slanted</h2>
    <p>Slide the offset to zero and the mortar lines become straight. Nudge it towards half a tile and your brain swears the mortar tilts. This is the core mechanism of the café wall illusion.</p>
    <div class="demo-surface">
      <canvas data-mirror="cafe-wall" aria-hidden="true"></canvas>
    </div>
    <div class="controls">
      <div class="control-row">
        <label for="offset">Offset per odd row (fraction of tile)</label>
        <input id="offset" type="range" min="0" max="1" step="0.01" value="0.5" />
        <span id="offsetVal" class="value">0.50</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-mortar">
    <p class="kicker">Step 2 · Mortar strip</p>
    <h2>Mortar thickness and shade set the illusion strength</h2>
    <p>Thin mortar that sits midway between the light and dark tiles maximises the contrast cue. Widen or darken it too much and the tilt fades away.</p>
    <div class="demo-surface">
      <canvas data-mirror="cafe-wall" aria-hidden="true"></canvas>
    </div>
    <div class="controls">
      <div class="control-row">
        <label for="mortar">Mortar width (px)</label>
        <input id="mortar" type="range" min="0" max="24" value="4" />
        <span id="mortarVal" class="value">4</span>
      </div>
      <div class="control-row">
        <label for="Lm">Mortar lightness</label>
        <input id="Lm" type="range" min="0" max="100" value="55" />
        <span id="LmVal" class="value">55%</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-tiles">
    <p class="kicker">Step 3 · Tile contrast</p>
    <h2>Boost the contrast between dark and light tiles</h2>
    <p>The illusion thrives on a strong contrast between tile rows. Tune the dark and light lightness values here to see how the mortar leans more convincingly.</p>
    <div class="demo-surface">
      <canvas data-mirror="cafe-wall" aria-hidden="true"></canvas>
    </div>
    <div class="controls">
      <div class="control-row">
        <label for="Ld">Dark tile lightness</label>
        <input id="Ld" type="range" min="0" max="40" value="10" />
        <span id="LdVal" class="value">10%</span>
      </div>
      <div class="control-row">
        <label for="Ll">Light tile lightness</label>
        <input id="Ll" type="range" min="60" max="100" value="90" />
        <span id="LlVal" class="value">90%</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-layout">
    <p class="kicker">Step 4 · Layout</p>
    <h2>Change the number and size of tiles</h2>
    <p>More rows and columns extend the effect across the canvas. Tile size and corner rounding let you match photographs of real café walls.</p>
    <div class="demo-surface">
      <canvas data-mirror="cafe-wall" aria-hidden="true"></canvas>
    </div>
    <div class="controls">
      <div class="control-row">
        <label for="rows">Rows</label>
        <input id="rows" type="range" min="4" max="40" value="14" />
        <span id="rowsVal" class="value">14</span>
      </div>
      <div class="control-row">
        <label for="cols">Columns</label>
        <input id="cols" type="range" min="6" max="80" value="30" />
        <span id="colsVal" class="value">30</span>
      </div>
      <div class="control-row">
        <label for="tile">Tile size (px)</label>
        <input id="tile" type="range" min="16" max="120" value="40" />
        <span id="tileVal" class="value">40</span>
      </div>
      <div class="control-row">
        <label for="round">Tile corner rounding (px)</label>
        <input id="round" type="range" min="0" max="18" value="0" />
        <span id="roundVal" class="value">0</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-offsetmodes">
    <p class="kicker">Step 5 · Pattern variations</p>
    <h2>Play with different offsets and mortar waves</h2>
    <p>Alternative offset modes and wavy mortar disrupt or exaggerate the effect. Add jitter to see how small amounts of disorder collapse the illusion.</p>
    <div class="demo-surface">
      <canvas data-mirror="cafe-wall" aria-hidden="true"></canvas>
    </div>
    <div class="controls">
      <div class="control-row">
        <label for="offsetMode">Offset mode</label>
        <select id="offsetMode">
          <option value="alternate" selected>Alternate rows (classic)</option>
          <option value="progressive">Progressive drift</option>
          <option value="mirror">Mirror (zig-zag)</option>
        </select>
        <span class="value" aria-hidden="true"></span>
      </div>
      <div class="control-row">
        <label for="wAmp">Wavy mortar amplitude (px)</label>
        <input id="wAmp" type="range" min="0" max="20" value="0" />
        <span id="wAmpVal" class="value">0</span>
      </div>
      <div class="control-row">
        <label for="wFreq">Wavy mortar frequency</label>
        <input id="wFreq" type="range" min="1" max="20" value="8" />
        <span id="wFreqVal" class="value">8</span>
      </div>
      <div class="control-row">
        <label for="jitter">Row jitter (px, disrupts illusion)</label>
        <input id="jitter" type="range" min="0" max="40" value="0" />
        <span id="jitterVal" class="value">0</span>
      </div>
    </div>
  </section>

  <section class="stage" id="stage-overlay">
    <p class="kicker">Step 6 · Guides and framing</p>
    <h2>Add reference lines and margins to compare</h2>
    <p>Reference rulers prove the mortar is level. A generous margin keeps the illusion readable even on small screens.</p>
    <div class="demo-surface">
      <canvas data-mirror="cafe-wall" aria-hidden="true"></canvas>
    </div>
    <div class="controls">
      <div class="control-check">
        <input id="refs" type="checkbox" checked />
        <label for="refs">Show straight reference lines</label>
      </div>
      <div class="control-row">
        <label for="margin">Board margin (px)</label>
        <input id="margin" type="range" min="10" max="120" value="40" />
        <span id="marginVal" class="value">40</span>
      </div>
      <div class="meter">
        <strong>Illusion score</strong>
        <span id="scoreTxt" class="badge">—</span>
      </div>
      <div class="meterbar"><i id="scoreBar" style="width:0%"></i></div>
      <p id="why" class="stage-footer">Adjust the controls to see why the score changes. Aim for mid-grey mortar, thin mortar, and roughly half-tile offsets.</p>
    </div>
  </section>

  <section class="stage" id="stage-presets">
    <p class="kicker">Step 7 · Presets & export</p>
    <h2>Try classic setups or save your own configuration</h2>
    <p>Use presets to jump to canonical café wall arrangements or export a snapshot as PNG or SVG to share the illusion.</p>
    <div class="demo-surface">
      <canvas data-mirror="cafe-wall" aria-hidden="true"></canvas>
    </div>
    <div class="controls">
      <div id="presetRow" class="presets"></div>
      <div class="button-row">
        <button id="exportPng" type="button">Export PNG</button>
        <button id="exportSvg" type="button">Export SVG</button>
        <button id="reset" type="button">Reset</button>
      </div>
    </div>
  </section>
</main>

<script>
(() => {
  const $ = id => document.getElementById(id);
  const cv = $('cv');
  const ctx = cv.getContext('2d');

  const ctl = {
    rows: $('rows'), cols: $('cols'), tile: $('tile'), round: $('round'),
    Ld: $('Ld'), Ll: $('Ll'),
    mortar: $('mortar'), Lm: $('Lm'), wAmp: $('wAmp'), wFreq: $('wFreq'),
    offset: $('offset'), offsetMode: $('offsetMode'), jitter: $('jitter'),
    refs: $('refs'), margin: $('margin')
  };
  const lab = {
    rows: $('rowsVal'), cols: $('colsVal'), tile: $('tileVal'), round: $('roundVal'),
    Ld: $('LdVal'), Ll: $('LlVal'),
    mortar: $('mortarVal'), Lm: $('LmVal'), wAmp: $('wAmpVal'), wFreq: $('wFreqVal'),
    offset: $('offsetVal'), jitter: $('jitterVal'), margin: $('marginVal')
  };
  const scoreTxt = $('scoreTxt');
  const scoreBar = $('scoreBar');
  const why = $('why');

  function fitCanvas(){
    const rect = cv.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    cv.width = Math.max(1, Math.round(rect.width * dpr));
    cv.height = Math.max(1, Math.round(rect.height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function L2hex(L){
    const v=Math.round(255*L/100);
    const h=v.toString(16).padStart(2,'0');
    return `#${h}${h}${h}`;
  }
  function clamp(v,a,b){ return Math.min(b, Math.max(a,v)); }
  function seededRand(i){ // deterministic pseudo-random for row jitter
    let x=(i*9301+49297)%233280; x=(x*9301+49297)%233280; return x/233280;
  }
  function roundRectPath(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.lineTo(x+w-rr,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+rr);
    ctx.lineTo(x+w,y+h-rr);
    ctx.quadraticCurveTo(x+w,y+h,x+w-rr,y+h);
    ctx.lineTo(x+rr,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-rr);
    ctx.lineTo(x,y+rr);
    ctx.quadraticCurveTo(x,y,x+rr,y);
    ctx.closePath();
  }

  function illusionScore(params){
    const {Ld,Ll,Lm,mortar,tile,offset,jitter} = params;
    const contrast = Math.abs(Ll - Ld)/100;
    const mid = (Ll+Ld)/2, dMid = Math.abs(Lm - mid);
    const mortarMid = clamp(1 - dMid / Math.max(1, (Ll-Ld)/2), 0, 1);
    const r = mortar / tile;
    const mortarOpt = Math.exp(-Math.pow((r-0.05)/0.05,2));
    const offF = Math.sin(Math.PI*offset);
    const jitF = 1 - clamp(jitter/(tile*0.8), 0, 1);
    const score = 100 * contrast * mortarMid * mortarOpt * offF * jitF;
    return clamp(score, 0, 100);
  }
  function describeScore(s){
    if (s>=75) return 'VERY STRONG — classic slant';
    if (s>=50) return 'strong';
    if (s>=25) return 'moderate';
    if (s>5)   return 'weak';
    return 'likely absent';
  }
  function whyText(p, s){
    const bits=[];
    const contrast = Math.abs(p.Ll - p.Ld);
    if (contrast < 30) bits.push('low tile contrast');
    const mid = (p.Ll+p.Ld)/2, dMid = Math.abs(p.Lm - mid);
    if (dMid > (contrast/3)) bits.push('mortar not near mid-grey');
    const r = p.mortar/p.tile;
    if (r < 0.02) bits.push('mortar too thin');
    if (r > 0.12) bits.push('mortar too thick');
    if (p.offset < 0.1 || p.offset > 0.9) bits.push('offset ~0 (aligned rows)');
    if (p.jitter > p.tile*0.5) bits.push('row jitter too high');
    if (bits.length===0) return 'Great: mid-grey mortar, thin-ish mortar, high contrast, and ~½-tile offset maximise the tilt.';
    return 'Weakeners: ' + bits.join('; ') + '.';
  }

  function draw(){
    lab.rows.textContent = ctl.rows.value;
    lab.cols.textContent = ctl.cols.value;
    lab.tile.textContent = ctl.tile.value;
    lab.round.textContent = ctl.round.value;
    lab.Ld.textContent = ctl.Ld.value + '%';
    lab.Ll.textContent = ctl.Ll.value + '%';
    lab.mortar.textContent = ctl.mortar.value;
    lab.Lm.textContent = ctl.Lm.value + '%';
    lab.wAmp.textContent = ctl.wAmp.value;
    lab.wFreq.textContent = ctl.wFreq.value;
    lab.offset.textContent = (+ctl.offset.value).toFixed(2);
    lab.jitter.textContent = ctl.jitter.value;
    lab.margin.textContent = ctl.margin.value;

    const W=cv.width, H=cv.height;
    ctx.clearRect(0,0,W,H);

    const rows=+ctl.rows.value, cols=+ctl.cols.value, tile=+ctl.tile.value, round=+ctl.round.value;
    const Ld=+ctl.Ld.value, Ll=+ctl.Ll.value, Lm=+ctl.Lm.value, mortar=+ctl.mortar.value;
    const wAmp=+ctl.wAmp.value, wFreq=+ctl.wFreq.value;
    const offsetF=+ctl.offset.value, mode=ctl.offsetMode.value, jitter=+ctl.jitter.value;
    const showRefs = ctl.refs.checked, margin=+ctl.margin.value;

    const boardW = cols*tile;
    const boardH = rows*tile + (rows-1)*mortar;
    const x0 = (W/2) - boardW/2;
    const y0 = (H/2) - boardH/2;

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = L2hex(Lm);
    for (let r=0; r<rows-1; r++){
      const yTop = y0 + (r+1)*tile + r*mortar;
      if (wAmp<=0){
        ctx.fillRect(x0 - margin, yTop, boardW + 2*margin, mortar);
      } else {
        const steps = Math.max(100, Math.floor(boardW/6));
        const phase = r*0.7;
        ctx.beginPath();
        for (let i=0;i<=steps;i++){
          const k=i/steps;
          const x = x0 + k*boardW;
          const y = yTop + wAmp*Math.sin((k*wFreq*2*Math.PI)+phase);
          if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        for (let i=steps;i>=0;i--){
          const k=i/steps;
          const x = x0 + k*boardW;
          const y = yTop + mortar + wAmp*Math.sin((k*wFreq*2*Math.PI)+phase+Math.PI*0.3);
          ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
      }
    }

    for (let r=0; r<rows; r++){
      let off = 0;
      if (mode === 'alternate'){
        off = (r%2 ? offsetF : 0)*tile;
      } else if (mode === 'progressive'){
        off = (r*offsetF % 1)*tile;
      } else if (mode === 'mirror'){
        const f = (r%2? offsetF : 1-offsetF);
        off = f*tile;
      }
      const j = jitter>0 ? (seededRand(r)*2-1)*jitter : 0;
      off += j;

      const y = y0 + r*(tile+mortar);
      for (let c=-1; c<=cols; c++){
        const x = x0 + c*tile + off;
        const light = ((r+c)&1) === 1;
        ctx.fillStyle = L2hex(light ? Ll : Ld);
        if (round>0) {
          roundRectPath(x,y,tile,tile,round);
          ctx.fill();
        } else {
          ctx.fillRect(x,y,tile,tile);
        }
      }
    }

    if (showRefs && mortar>0){
      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 1;
      ctx.setLineDash([6,6]);
      for (let r=0;r<rows-1;r++){
        const yTop = y0 + (r+1)*tile + r*mortar;
        const yMid = yTop + mortar/2;
        ctx.beginPath();
        ctx.moveTo(x0 - margin, yMid);
        ctx.lineTo(x0 + boardW + margin, yMid);
        ctx.stroke();
      }
      ctx.restore();
    }

    ctx.save();
    ctx.strokeStyle = '#9ca3af';
    ctx.lineWidth = 1;
    ctx.strokeRect(x0 - margin, y0 - margin, boardW + 2*margin, boardH + 2*margin);
    ctx.restore();

    const s = illusionScore({Ld,Ll,Lm,mortar,tile,offset:offsetF,jitter});
    scoreBar.style.width = s.toFixed(0)+'%';
    scoreTxt.textContent = `${s.toFixed(0)}/100 · ${describeScore(s)}`;
    why.textContent = whyText({Ld,Ll,Lm,mortar,tile,offset:offsetF,jitter}, s);
  }

  const presets = [
    { id:'classic', name:'Classic (strong)', rows:14, cols:30, tile:40, round:0, Ld:10, Ll:90, mortar:4, Lm:55, wAmp:0, wFreq:8, offset:0.5, offsetMode:'alternate', jitter:0, refs:true, margin:40 },
    { id:'super', name:'Super-strong (micro mortar)', rows:18, cols:48, tile:28, round:0, Ld:8, Ll:94, mortar:2, Lm:50, wAmp:0, wFreq:8, offset:0.5, offsetMode:'alternate', jitter:0, refs:true, margin:30 },
    { id:'wavy', name:'Extreme (wavy mortar)', rows:16, cols:40, tile:36, round:0, Ld:8, Ll:92, mortar:5, Lm:55, wAmp:8, wFreq:10, offset:0.5, offsetMode:'alternate', jitter:0, refs:true, margin:40 },
    { id:'subtle', name:'Subtle version', rows:12, cols:28, tile:42, round:4, Ld:20, Ll:85, mortar:8, Lm:60, wAmp:0, wFreq:8, offset:0.4, offsetMode:'alternate', jitter:4, refs:true, margin:40 },
    { id:'no_offset', name:'No illusion: offset = 0', rows:14, cols:30, tile:40, round:0, Ld:10, Ll:90, mortar:4, Lm:55, wAmp:0, wFreq:8, offset:0.0, offsetMode:'alternate', jitter:0, refs:true, margin:40 },
    { id:'no_mortar', name:'No illusion: mortar = 0', rows:14, cols:30, tile:40, round:0, Ld:10, Ll:90, mortar:0, Lm:55, wAmp:0, wFreq:8, offset:0.5, offsetMode:'alternate', jitter:0, refs:true, margin:40 },
    { id:'bad_mortar', name:'No illusion: mortar near black/white', rows:14, cols:30, tile:40, round:0, Ld:10, Ll:90, mortar:6, Lm:90, wAmp:0, wFreq:8, offset:0.5, offsetMode:'alternate', jitter:0, refs:true, margin:40 },
    { id:'low_contrast', name:'No illusion: low contrast', rows:14, cols:30, tile:40, round:0, Ld:40, Ll:60, mortar:6, Lm:50, wAmp:0, wFreq:8, offset:0.5, offsetMode:'alternate', jitter:0, refs:true, margin:40 },
    { id:'jittered', name:'Collapse: heavy jitter', rows:14, cols:30, tile:40, round:0, Ld:10, Ll:90, mortar:4, Lm:55, wAmp:0, wFreq:8, offset:0.5, offsetMode:'alternate', jitter:28, refs:true, margin:40 }
  ];
  const presetRow = $('presetRow');
  function applyPreset(p){
    ctl.rows.value=p.rows; ctl.cols.value=p.cols; ctl.tile.value=p.tile; ctl.round.value=p.round;
    ctl.Ld.value=p.Ld; ctl.Ll.value=p.Ll; ctl.mortar.value=p.mortar; ctl.Lm.value=p.Lm;
    ctl.wAmp.value=p.wAmp; ctl.wFreq.value=p.wFreq; ctl.offset.value=p.offset;
    ctl.offsetMode.value=p.offsetMode; ctl.jitter.value=p.jitter; ctl.refs.checked=!!p.refs; ctl.margin.value=p.margin;
    draw();
  }
  function buildPresetButtons(){
    presets.forEach(p=>{
      const b=document.createElement('button');
      b.textContent=p.name;
      b.addEventListener('click', ()=> applyPreset(p));
      presetRow.appendChild(b);
    });
  }

  $('exportPng').addEventListener('click', ()=>{
    const a=document.createElement('a');
    a.download='cafe-wall.png';
    a.href=cv.toDataURL('image/png');
    a.click();
  });

  $('exportSvg').addEventListener('click', ()=>{
    const rect = cv.getBoundingClientRect();
    const W = Math.round(rect.width), H = Math.round(rect.height);

    const rows=+ctl.rows.value, cols=+ctl.cols.value, tile=+ctl.tile.value, round=+ctl.round.value;
    const Ld=+ctl.Ld.value, Ll=+ctl.Ll.value, Lm=+ctl.Lm.value, mortar=+ctl.mortar.value;
    const wAmp=+ctl.wAmp.value, wFreq=+ctl.wFreq.value;
    const offsetF=+ctl.offset.value, mode=ctl.offsetMode.value, jitter=+ctl.jitter.value;
    const showRefs = ctl.refs.checked, margin=+ctl.margin.value;

    const boardW = cols*tile;
    const boardH = rows*tile + (rows-1)*mortar;
    const x0 = W/2 - boardW/2;
    const y0 = H/2 - boardH/2;

    const parts=[];
    parts.push(`<rect x="0" y="0" width="${W}" height="${H}" fill="#ffffff"/>`);

    parts.push(`<!-- mortar -->`);
    for (let r=0;r<rows-1;r++){
      const yTop = y0 + (r+1)*tile + r*mortar;
      const fill=L2hex(Lm);
      if (wAmp<=0){
        parts.push(`<rect x="${x0 - margin}" y="${yTop}" width="${boardW + 2*margin}" height="${mortar}" fill="${fill}"/>`);
      }else{
        const steps = Math.max(100, Math.floor(boardW/6));
        const phase = r*0.7;
        let d=`M ${x0} ${yTop + wAmp*Math.sin(phase)}`;
        for (let i=1;i<=steps;i++){
          const k=i/steps, x=x0+k*boardW, y=yTop + wAmp*Math.sin(k*wFreq*2*Math.PI+phase);
          d+=` L ${x.toFixed(2)} ${y.toFixed(2)}`;
        }
        for (let i=steps;i>=0;i--){
          const k=i/steps, x=x0+k*boardW, y=yTop + mortar + wAmp*Math.sin(k*wFreq*2*Math.PI+phase+Math.PI*0.3);
          d+=` L ${x.toFixed(2)} ${y.toFixed(2)}`;
        }
        d+=` Z`;
        parts.push(`<path d="${d}" fill="${fill}"/>`);
      }
    }

    parts.push(`<!-- tiles -->`);
    for (let r=0;r<rows;r++){
      let off=0;
      if (mode==='alternate') off=(r%2? offsetF:0)*tile;
      else if (mode==='progressive') off=((r*offsetF)%1)*tile;
      else if (mode==='mirror') off=((r%2? offsetF:1-offsetF))*tile;
      const j = jitter>0 ? (seededRand(r)*2-1)*jitter : 0;
      off += j;
      const y = y0 + r*(tile+mortar);
      for (let c=-1;c<=cols;c++){
        const x = x0 + c*tile + off;
        const light = ((r+c)&1)===1;
        const fill=L2hex(light? Ll: Ld);
        if (round>0){
          const rx = Math.min(round, tile/2);
          parts.push(`<rect x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${tile}" height="${tile}" rx="${rx}" ry="${rx}" fill="${fill}"/>`);
        }else{
          parts.push(`<rect x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${tile}" height="${tile}" fill="${fill}"/>`);
        }
      }
    }

    if (showRefs && mortar>0){
      parts.push(`<!-- straight reference lines -->`);
      for (let r=0;r<rows-1;r++){
        const yTop = y0 + (r+1)*tile + r*mortar;
        const yMid = yTop + mortar/2;
        parts.push(`<line x1="${x0 - margin}" y1="${yMid}" x2="${x0 + boardW + margin}" y2="${yMid}" stroke="rgba(0,0,0,0.25)" stroke-width="1" stroke-dasharray="6 6"/>`);
      }
    }

    parts.push(`<rect x="${x0 - margin}" y="${y0 - margin}" width="${boardW + 2*margin}" height="${boardH + 2*margin}" fill="none" stroke="#9ca3af" stroke-width="1"/>`);

    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">\n${parts.join('\n')}\n</svg>`;
    const blob = new Blob([svg], {type:'image/svg+xml'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='cafe-wall.svg'; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  });

  $('reset').addEventListener('click', ()=> applyPreset(presets[0]));

  function bindInputs(){
    document.querySelectorAll('input,select').forEach(inp=>{
      const ev = (inp.tagName==='SELECT'||inp.type==='checkbox')?'change':'input';
      inp.addEventListener(ev, draw, {passive:true});
    });
    window.addEventListener('resize', ()=>{ fitCanvas(); draw(); }, {passive:true});
  }

  function init(){
    fitCanvas();
    buildPresetButtons();
    bindInputs();
    applyPreset(presets[0]);
  }
  init();
})();
</script>
</body>
</html>
